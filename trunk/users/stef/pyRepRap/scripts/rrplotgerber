#!/usr/bin/python

import reprap, pygame, thread, time, math, sys

#enableReprap = False
#enablePreview = False
#debug = False

#enableReprap = True
#enablePreview = True
#
#debug = True

stepsPmmX = 30
stepsPmmY = 30

#scale = 5	# just make thinks a bit bigger to look at in debugging
scale = 1	# normally 1, 1 unless you want to print enlarged. todo : combine into one scale factor (x and y)
moveSpeed = 220
torque = 83	# (83%)
units = "MM"

reprap.cartesian.x.limit = 2523		# 84.1mm
reprap.cartesian.y.limit = 2000		# 66.7mm

FS_ABSOLUTE = 1
FS_INCREMENTAL = 2



plotLines = []

class aperture:
	def __init__( self, paramString ):
		commorPos = paramString.find( ',' )
		self.code = int( paramString[ 3 : commorPos - 1 ] )
		self.apertureType = paramString[ commorPos - 1 : commorPos ]
		modString = paramString[ commorPos + 1 : -1 ]
		self.modifiers = []
		lastDiv = 0
		divPos = modString.find( 'X' )
		while divPos > 0:
			divPos = modString.find( 'X' )
			self.modifiers.append( modString[ lastDiv : divPos ] )
			modString = modString[ lastDiv : ]
			lastDiv = divPos
		self.modifiers.append( float(modString) )
		print "Loaded aperture", self.code, self.apertureType, self.modifiers
		# modifiers left in native units and converted as used


def steps( line ):
	x1, y1, x2, y2 = line
	return ( x1 * stepsPmmX, y1 * stepsPmmY, x2 * stepsPmmX, y2 * stepsPmmY )

class plotGerber:
	def __init__( self, fileName, offset = (0, 0), fillDensity = 4 ):
		self.apertures = {}
		self.currentAperture = False
		self.offsetX, self.offsetY = offset
		self.fillDensity = fillDensity
		if enablePreview:
			thread.start_new_thread( previewThread, () )
		self.currentX, self.currentY = 0, 0
		f = open( fileName, 'r' )
		print "{{{{{{{{{{{{{{{{{{{{{{{{{ START }}}}}}}}}}}}}}}}}}}}}}}}}}\n{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\n\n"
		lines = f.readlines()
		self.parseLines(lines)

	def parseLines( self, lines ):
		for l in lines:
			#print "Reading line '" + l[ : -1 ] + "'"
			firstChr = l[ : 1 ]
			lastChr = l[ -2 : -1 ]
			if firstChr == "G" and lastChr == "*":
				self.cmdGcode( l[ 1 : -2 ] )
			elif firstChr == "%" and lastChr == "%":
				self.cmdParameter( l[ 1 : -2 ] )
			elif firstChr == "X" and lastChr == "*":
				self.cmdMove( l[ : -2 ] )
			elif firstChr == "M" and lastChr == "*":
				self.cmdMisc( l[ 1 : -2 ] )
			else:
				print "Line error!"

	def cmdMisc( self, mstring ):
		code = int( mstring[ : 2 ] )
		remains = mstring[ 2: ]
		print "MCODE", code, remains

	def cmdGcode( self, gstring ):
		code = int( gstring[ : 2 ] )
		remains = gstring[ 2: ]
		if code == 0:
			print "Move", "[COMMAND UNSUPORTED!]"
		elif code == 1:
			print "Linear interpolation (1X scale)", "[COMMAND UNSUPORTED!]"
		elif code == 2:
			print "Clockwise circular interpolation", "[COMMAND UNSUPORTED!]"
		elif code == 3:
			print "Counterclockwise circular interpolation", "[COMMAND UNSUPORTED!]"
		elif code == 4:
			# Ignore Line
			#print "Comment", remains
			comment = False
		elif code == 10:
			print "Linear interpolation (10X scale)", "[COMMAND UNSUPORTED!]"
		elif code == 11:
			print "Linear interpolation (0.1X scale)", "[COMMAND UNSUPORTED!]"
		elif code == 12:
			print "Linear interpolation (0.01X scale)", "[COMMAND UNSUPORTED!]"
		elif code == 36:
			print "Turn on Polygon Area Fill", "[COMMAND UNSUPORTED!]"
		elif code == 37:
			print "Turn off Polygon Area Fill", "[COMMAND UNSUPORTED!]"
		elif code == 54:
			print "Tool prepare"
			if remains[ : 1 ] == "D":
				print "    Selecting aperture", int( remains[ 1 : ] )
			self.currentAperture = self.apertures[ int( remains[ 1 : ] ) ]
			#print currentAperture.modifiers[0]
		elif code == 70:
			print "Specify inches"							# why are there two ways of setting units?
			self.units = "IN"
		elif code == 71:
			print "Specify millimeters"
			self.units = "MM"
		elif code == 74:
			print "Disable 360 deg circular interpolation (single quadrant)", "[COMMAND UNSUPORTED!]"
		elif code == 75:
			print "Enable 360 deg circular interpolation (multiquadrant)", "[COMMAND UNSUPORTED!]"
		elif code == 90:
			print "Absolute coordinate format"
			self.FSparameter = FS_ABSOLUTE
		elif code == 91:
			print "Incremental coordinate format - This mode is not supported"
			self.FSparameter = FS_INCREMENTAL
			
		else:
			print "COMMAND UNKNOWN",

	def cmdParameter( self, paramString ):
		#print "Parameter", paramString, paramString[ : 2]

		if paramString[ : 3 ] == "ADD" and paramString[ -1 : ] == "*":
			newAperture = aperture( paramString )
			self.apertures[ newAperture.code ] = newAperture
		elif paramString[ : 2 ] == "MO" and paramString[ -1 : ] == "*":
			self.units = paramString[ 2 : -1 ]
		else:
			print "PARAMETER UNKNOWN"

	def cmdMove( self, moveString ):
		global currentX, currentY
		#print "Move", moveString
		yPos = moveString.find( 'Y' )
		dPos = moveString.find( 'D' )
		x = float( moveString[ 1 : yPos ] ) / float(10000)	# need to read this value from the file? or work out dp
		y = float( moveString[ yPos + 1 : dPos ] ) / -float(10000)
		if self.units == "IN":
			#print "CONV"
			# convert to mm
			x = x * 25.4
			y = y * 25.4
		d = int( moveString[ dPos + 1 : ] )
		x, y = x + self.offsetX, y + self.offsetY
		print "Move [", x, "mm,", y, "mm],", d
		if d == 1:
			#assuming always circle at the moment
			radius = self.currentAperture.modifiers[0] / 2		# half diameter
			if self.units == "IN":
				radius = radius * 25.4
			if debug: print "aperture radius", radius, "mm"
			plotMoveWithCircle( currentX, currentY, x, y, radius, self.fillDensity )
		#elif d == 2:
			
		elif d == 3:
			print "Implement flash code"
			#assuming always circle at the moment
			radius = self.currentAperture.modifiers[0] / 2		# half diameter
			if self.units == "IN":
				radius = radius * 25.4
			if debug: print "aperture radius", radius, "mm"
			plotCircle( x, y, radius, self.fillDensity )
		currentX, currentY = x, y


def calcCircle(theta, radius):
	x = math.cos( math.radians(theta) ) * radius
	y = math.sin( math.radians(theta) ) * radius
	return x, y

def angleFromDeltas( dx, dy ):
	radius = math.sqrt( ( dx * dx ) + ( dy * dy ) )
	dx, dy = dx / radius, dy / radius
	if dx > 0:
		if dy > 0:
			return math.asin(dx)
		elif dy < 0:
			return math.acos(dx) + math.radians(90)
		else:
			#print "moo1"
			return 0
	elif dx < 0:
		if dy > 0:
			return math.asin(dy) + math.radians(270)
		elif dy < 0:
			return math.radians(180) - math.asin(dx)
		else:
			#print "moo2"
			return 0
	else:
		return math.radians(-90)	# i think this should really be 90, it just makes thae program work wen its -90 :)

def plotArc( x, y, radius, startAngle, endAngle, resolution = 1):
	# This function works in degrees but takes parameters in radians
	if debug: print "Plotting arc at", x, y, "from", startAngle, "(", math.degrees(startAngle), ") to", endAngle, "(", math.degrees(endAngle), ")"
	startAngle, endAngle = math.degrees(startAngle), math.degrees(endAngle)
	angleDiv = 20									# fixed until we can make it better
	lastX, lastY = calcCircle( startAngle, radius )
	if startAngle > endAngle:
		endAngle += 360								# compensate for arc going beyond 360 deg
	for theta in range( int(startAngle), int( endAngle + angleDiv ), angleDiv ):	# make detail proportional to radius to always give good resolution
		newX, newY = calcCircle( theta, radius )
		aLine = ( lastX + x ) * scale , ( lastY + y ) * scale , ( newX + x ) * scale, ( newY + y ) * scale
		if debug: print "aLine", aLine
		plotLine( aLine )
		lastX, lastY = newX, newY

def plotCircle( x, y, radius, fillDensity ):
	numFills = int( float(fillDensity) * float(radius) )
	for d in range( 1, numFills + 1 ):
		r = ( float(d) / float(numFills) ) * float(radius)		# we really want a fill density to be in actual specifiable mm, not a factor.
		if debug: print "using r", r, "mm"
		plotArc( x, y, r, math.radians(0), math.radians(360) )

def reverseLine( line ):
	x1, y1, x2, y2 = line
	return x2, y2, x1, y1

def plotMoveWithCircle( x1, y1, x2, y2, radius, fillDensity ):
	# this code is not quite right at the moment, notice how ends of lines are not quite where they should be
	# rearrange the order we plot in to create almost continual movement
	deltaY = y2 - y1
	deltaX = x2 - x1

	centreLine = ( x1 * scale, y1 * scale, x2 * scale, y2 * scale )
	plotLine( centreLine )

	numFills = int( float(fillDensity) * float(radius) )
	for d in range( 1, numFills + 1 ):
		r = ( float(d) / float(numFills) ) * float(radius)		# we really want a fill density to be in actual specifiable mm, not a factor.
		if debug: print "using r", r, "mm"

		theta = angleFromDeltas( deltaX, deltaY )
		#print "th", math.degrees(theta)
		rsintheta = r * math.sin( theta )
		rcostheta = r * math.cos( theta )
		#print "rs", rsintheta, "rc", rcostheta	
		line1 = ( ( x1 - rsintheta) * scale, ( y1 + rcostheta ) * scale, ( x2 - rsintheta ) * scale, ( y2 + rcostheta ) * scale )		# two lines of locus
		line1 = reverseLine( line1 )														# reversing this lets locus be drawn in one continual motion
		line2 = ( ( x1 + rsintheta ) * scale, ( y1 - rcostheta ) * scale, ( x2 + rsintheta ) * scale, ( y2 - rcostheta ) * scale )		#
		if debug:
			print "line1", line1
			print "line2", line2
		if deltaX > 0:
			startOffset = math.radians(90)
			endOffset = math.radians(-90)
		else:
			startOffset = math.radians(-90)
			endOffset = math.radians(90)
		if deltaY < 0:
			startOffset = -startOffset
			endOffset = -endOffset


		plotLine( line1 )		
		plotArc( x1, y1, r, theta + startOffset, theta + endOffset )	# arc at start
		plotLine( line2 )
		plotArc( x2, y2, r, theta + -startOffset, theta + -endOffset )	# arc at end
	
	
	#print "Plotting", currentX * scale, currentY * scale, x * scale, y * scale


def plotLine( line ):
	# everything is in mm until this point
	lineSteps = steps(line)
	if enableReprap:
		reprapPlotLine( lineSteps )
	if enablePreview:
		plotLines.append( lineSteps )
		if debug: print "JP", line, "mm", lineSteps, "steps"
		time.sleep(0.01)
		#raw_input('Press <enter> to continue')

def reprapPlotLine( line ):
	x1, y1, x2, y2 = line
	if debug: print "RR PRINT LINE", x1, y1, x2, y2
	reprap.cartesian.seek( ( int(x1), int(y1), 0 ), moveSpeed, True )	# add toolhead lift / drop
	reprap.cartesian.seek( ( int(x2), int(y2), 0 ), moveSpeed, True )
	# note - put int functions into reprap module to stop this happening again!

def previewThread():
	global plotLines
	pygame.init()
	windowZoom = 0.4
	width = int( reprap.cartesian.x.limit * windowZoom )
	height = int( reprap.cartesian.y.limit * windowZoom )
	#width, height = 800, 800
	
	window = pygame.display.set_mode( [width, height] )
	pygame.display.set_caption('gerberPlot')
	pygame.display.flip()
	#plotArc( 4, 4, 1, math.radians(90), math.radians(180), 1 )
	while 1:
		plotColour = [255, 255, 255]
		window.fill( [0, 0, 0] )
		for l in plotLines:
			x1, y1, x2, y2 = l
			x1, y1, x2, y2 = x1 * windowZoom, y1 * windowZoom, x2 * windowZoom, y2 * windowZoom
			pygame.draw.line( window, plotColour, (x1, y1), (x2, y2) )
		pygame.display.update()	
		time.sleep(0.01)	
	pygame.display.quit()


mode = ""
debug = False
enableReprap = False
enableScreen = False
linePause = 0
plotOffset = 5, 5

for i in range( len( sys.argv ) ):
	arg = sys.argv[i]
	if arg == "-r" or arg == "--reprap":
		mode = "plot"
		enableReprap = True		
	elif arg == "-s" or arg == "--screen":
		mode = "plot"
		enablePreview = True
	elif arg == "-l" or arg == "--linedelay":
		linePause = float( sys.argv[ i + 1 ] )
	elif arg == "-d" or arg == "--debug":
		debug = True
	elif arg == "-o" or arg == "--offset":
		plotOffset = int( sys.argv[ i + 1 ] ), int( sys.argv[ i + 2 ] )
	elif arg == "-m" or arg == "--disablelimit":
		reprap.cartesian.x.limit = 9999999
		reprap.cartesian.y.limit = 9999999
	elif arg == "-a" or arg == "--arealimit":
		reprap.cartesian.x.limit = int( sys.argv[ i + 1 ] )
		reprap.cartesian.y.limit = int( sys.argv[ i + 2 ] )
	elif arg == "-h" or arg == "--help":
		mode = "help"

#TO ADD : steps per mm, move speed, torque

fileName = sys.argv[ -1 : ][0] 
print fileName

if mode == "plot":
	if enableReprap:
		reprap.openSerial( 0, 19200, 60 )						# Initialise serial port, here the first port (0) is used, timeout 60 seconds.
		reprap.cartesian.x.active = True						# These devices are present in network, will automatically scan in the future.
		reprap.cartesian.y.active = True
		reprap.cartesian.z.active = True

		reprap.cartesian.x.setNotify()						
		reprap.cartesian.y.setNotify()
		reprap.cartesian.z.setNotify()

		reprap.cartesian.setPower( int( torque * 0.63 ) )
		reprap.cartesian.homeReset( moveSpeed, True )

	plotGerber( fileName, offset = plotOffset, fillDensity = 4 )	# offset in mm, fill density in lines per mm


	time.sleep(0.5)
	if enableReprap:
		reprap.cartesian.free()
	#raw_input('Press <enter> to end')
else:
	print "Usage: rrplotgerber [OPTION] [FILE]"
	print "Plot gerber files on a RepRap\n"
	print "   -r,  --reprap               Plot to RepRap (over serial)"
	print "   -s,  --screen               Plot to screen (pygame required)"
	print "   -l,  --linedelay [seconds]  Number of seconds to pause between lines (for testing)"
	print "   -d,  --debug                Print debug info"
	print "   -o,  --offset [x] [y]       Plot offset in mm"
	print "   -m,  --disablelimit         Disables print area limiting"
	print "   -a,  --arealimit [x] [y]    Set build area safety limit. Units are steps not mm."
	print "   TO ADD : steps per mm, move speed, torque"
	print "   -h,  --help                 Show this help)\n"
	print "Examples:"
	print "   rrplotgerber -s -r -o 10 10 file.pho"
	print "   Plot the 'file.pho' to RepRap and the screen with an offset of (10mm, 10mm)."
	print "   rrplotgerber --screen --linedelay 0.1 file.pho"
	print "   Plot the 'file.pho' to screen with a 0.1 sec delay between lines."
        print "Notes:"
	print "   Most people will want to use the --disablelimit option."
	print "   This disables the build area safty limitation which is set for my machine"
	print "   with and area of only 84.1mm x 66.7mm"
	print "   If you want to set up the safety limit for your machine use --arealimit"
	






