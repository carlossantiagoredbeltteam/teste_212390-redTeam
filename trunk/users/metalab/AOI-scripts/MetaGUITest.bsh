/*
<?xml version='1.0' standalone='yes' ?>
<!--  xml header for scripts & plugin manager --> 
<script>
  <name>MetaGuiTest</name>
  <author>Philipp Tiefenbacher, Stefan Farthofer and Marius Kintel (Metalab)</author>
  <version>1.0</version>
  <beta>1</beta>
  <date>2/11/2008</date>
  <description>
    FIXME: MetaMagic
  </description>
  <comments>
  </comments>
</script>
*/

class MetaCAD
{
    public static String opToString(int operation) {
	switch (operation) {
	case CSGObject.UNION:
	    return "union";
	    break;
	case CSGObject.INTERSECTION:
	    return "intersection";
	    break;
	case CSGObject.DIFFERENCE12:
	    return "difference";
	    break;
	default:
	    return null;
	}
    }

    public static int stringToOp(String opstr) {
	String lower = opstr.toLowerCase();
	if (lower.startsWith("union") || lower.startsWith("+")) {
	    return CSGObject.UNION;
	}
	else if (lower.startsWith("intersection") || lower.startsWith("/")) {
	    return CSGObject.INTERSECTION;
	}
	else if (opstr.equalsIgnoreCase("difference") || lower.startsWith("-")) {
	    return CSGObject.DIFFERENCE12;
	}
	else return -1;
    }

    /*
      Recursively (Re-)evaluates the object tree rooted at the given root object
      based on the object name.

      The result should be one CSG object where the entire child tree is disabled.
    */
    public static ObjectInfo evaluateNode(ObjectInfo parent)
    {
	int op = stringToOp(parent.name);
	if (op == -1) return parent;
	else return combine(parent, op);
    }

    /*
      Recursively (Re-)deevaluates the object tree rooted at the given root object
      based on the object name.

      This disables all implicit (parent) objects and enabled the leaf nodes.
    */
    public static void devaluateNode(ObjectInfo parent)
    {
	int op = stringToOp(parent.name);
	if (op != -1 && parent.object.getClass() == CSGObject.class) {
	    parent.setVisible(false);
	    window.getScene().objectModified(parent.getObject());
	    ObjectInfo[] children = parent.getChildren();
	    for (int i=0;i<children.length;i++) {
		devaluateNode(children[i]);
	    }
	}
	else {
	    parent.setVisible(true);
	    window.getScene().objectModified(parent.getObject());
	}
    }

    /*
      Performs the given operation on all the children of the given object.
      Recursively calls evaluateNode() on each child.
     */	
    public static ObjectInfo combine(ObjectInfo parent, int operation)
    {
	ObjectInfo unioninfo = combine(parent.getChildren(), operation);
	parent.object.copyObject(unioninfo.object);
	parent.setCoords(new CoordinateSystem());
	parent.setVisible(true);
	parent.clearCachedMeshes();		
	window.getScene().objectModified(parent.object);
		
	return parent;
    }

    /*
      Performs the given operation on the list of objects (of size >= 2),
      and returns the resulting ObjectInfo containing a CSGObject.

      Calls evaluateNode() on each child.
    */
    public static ObjectInfo combine(ObjectInfo[] objects, int operation)
    {
	if (objects.length < 1) return null;
	if (objects.length < 2) return objects[0];

	Object3D unionobj = new CSGObject(evaluateNode(objects[0]), 
					  evaluateNode(objects[1]), 
					  operation);
	ObjectInfo unioninfo = new ObjectInfo(unionobj, new CoordinateSystem(), "tmp");
	for (int i=2;i<objects.length;i++) {
	    unionobj = new CSGObject(unioninfo, evaluateNode(objects[i]), operation);
	    unioninfo = new ObjectInfo(unionobj, new CoordinateSystem(), "tmp");
	}

	for (int i=0;i<objects.length;i++) {
	    objects[i].setVisible(false);
	    window.getScene().objectModified(objects[i].getObject());
	}
	return unioninfo;
    }

    /*
      Creates a new object consisting of the result of performing the given
      operation on the given list of objects (of length >= 2).

      Inserts the new object into the scene and makes the original objects
      children of the new object. Also hides the children.
    */
    public static ObjectInfo create(ObjectInfo[] objects, int operation)
    {
 	ObjectInfo result = combine(objects, operation);
	result.setName(opToString(operation));
	for (int i=0;i<objects.length;i++) {
	    result.addChild(objects[i], i);
	}
	window.getScene().addObject(result, null);
	window.rebuildItemList();
	window.clearSelection();
	window.addToSelection(window.getScene().indexOf(result));
	
	return result;
    }
}

// dummy needed to make ComponentsDialog nonmodal
class MetaCADDummyCallback implements java.lang.Runnable
{
    public void run()
    {
	// We don't care if we are called
    }
}

class MetaCADCallbacks
{
    public ObjectInfo[] getSelection() {
	sel = window.getSelectedObjects();
	if (sel.size() < 2) {
	    new MessageDialog(window, "Minimum two objects must be selected.");
	    return null;
	}
	else {
	    ObjectInfo[] objects = new ObjectInfo[sel.size()];
	    it = sel.iterator();
	    int i = 0;
	    while (it.hasNext()) {
		objects[i++] = it.next();
	    }
	    return objects;
	}
    }

    public void evaluate()
    {
	sel = window.getSelectedObjects();
	
	it = sel.iterator();
	while (it.hasNext()) {
	    MetaCAD.evaluateNode(it.next());
	}
	window.rebuildItemList();
	window.updateImage();
	window.setModified();
    }
	
    public void devaluate()
    {
	sel = window.getSelectedObjects();
	
	it = sel.iterator();
	while (it.hasNext()) {
	    MetaCAD.devaluateNode(it.next());
	}
	window.rebuildItemList();
	window.updateImage();
	window.setModified();
    }
	
    public void union()
    {
	ObjectInfo[] objects = getSelection();
	if (objects != null) {
	    ObjectInfo result = MetaCAD.create(objects, CSGObject.UNION);
	}
	window.updateImage();
	window.setModified();
    }
	
    public void intersect()
    {
	ObjectInfo[] objects = getSelection();
	if (objects != null) {
	    ObjectInfo result = MetaCAD.create(objects, CSGObject.INTERSECTION);
	}
	window.updateImage();
	window.setModified();
    }
	
    public void subtract()
    {
	ObjectInfo[] objects = getSelection();
	if (objects != null) {
	    ObjectInfo result = MetaCAD.create(objects, CSGObject.DIFFERENCE12);
	}
	window.setModified();
	window.updateImage();
    }
}

	
	
BButton evaluateButton, devaluateButton;
BButton unionButton, intersectButton, subtractButton;


dlg = new ComponentsDialog(window, "MetaCAD Control Panel" ,
			   new Widget [] { 
			       evaluateButton = new BButton( "evaluate" ),
			       devaluateButton = new BButton( "devaluate" ),

			       unionButton = new BButton( "union" ),
			       intersectButton = new BButton( "intersect" ),
			       subtractButton = new BButton( "subtract" ),
			   },
			   new String [] {"Actions", "", "Boolean Operations", "", ""}, new MetaCADDummyCallback(), new MetaCADDummyCallback() );
dlg.setOkEnabled(false);

MetaCADCallbacks callbacks = new MetaCADCallbacks();

evaluateButton.addEventLink(CommandEvent.class, callbacks, "evaluate" );
devaluateButton.addEventLink(CommandEvent.class, callbacks, "devaluate" );

unionButton.addEventLink(CommandEvent.class, callbacks, "union" );
intersectButton.addEventLink(CommandEvent.class, callbacks, "intersect" );
subtractButton.addEventLink(CommandEvent.class, callbacks, "subtract" );

