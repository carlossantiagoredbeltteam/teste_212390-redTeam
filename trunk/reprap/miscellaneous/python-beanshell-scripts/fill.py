#! /usr/bin/env python
"""
Fill is a script to fill the slices of a gcode file.

To run fill, install python 2.x on your machine, which is avaliable from http://www.python.org/download/

To use the preferences dialog you'll also need Tkinter, which probably came with the python installation.  If it did not, look for it at:
www.tcl.tk/software/tcltk/

To export a GNU Triangulated Surface file from Art of Illusion, you can use the Export GNU Triangulated Surface script at:
http://members.axion.net/~enrique/Export%20GNU%20Triangulated%20Surface.bsh

To bring it into Art of Illusion, drop it into the folder ArtOfIllusion/Scripts/Tools/.

The GNU Triangulated Surface format is supported by Mesh Viewer, and it is described at:
http://gts.sourceforge.net/reference/gts-surfaces.html#GTS-SURFACE-WRITE

To turn an STL file into filled gcode, first import the file using the STL import plugin in the import submenu of the file menu of Art of Illusion.
Then from the Scripts submenu in the Tools menu, choose Skeinforge and select the imported STL shape.  In the Fill radio button group,
choose Slice and click the 'Export Selected' checkbox.  Set the parameters and click OK.  Then type 'python fill.py' in a shell in the folder
which fill is in and when the dialog pops up, then click 'Fill', choose the file which you exported in
Export GNU Triangulated Surface and the filled file will be saved with the suffix '_fill'.

To write documentation for this program, open a shell in the fill.py directory, then type 'pydoc -w fill', then open 'fill.html' in a browser
or click on the '?' button in the dialog.  To use other functions of fill, type 'python' in a shell to run the python interpreter, then type 'import fill'
to import this program.

The computation intensive python modules will use psyco if it is available and run about twice as fast.  Psyco is described at:
http://psyco.sourceforge.net/index.html

The psyco download page is:
http://psyco.sourceforge.net/download.html

The following examples fillet the files Hollow Square.gcode & Hollow Square.gts.  The examples are run in a terminal in the folder which contains
Hollow Square.gcode, Hollow Square.gts and fill.py.  The preferences can be set in the dialog or by changing the preferences file 'fill.csv' with a text editor
or a spreadsheet program set to separate tabs.


> pydoc -w fill
wrote fill.html


> python fill.py
This brings up the dialog, after clicking 'Fill', the following is printed:
File Hollow Square.gts is being chain filled.
The filled file is saved as Hollow Square_fill.gcode


>python
Python 2.5.1 (r251:54863, Sep 22 2007, 01:43:31)
[GCC 4.2.1 (SUSE Linux)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import fill
>>> fill.main()
File Hollow Square.gts is being filled.
The filled file is saved as Hollow Square_fill.gcode
It took 3 seconds to fill the file.


>>> fill.fillChainFile()
File Hollow Square.gts is being filled.
The filled file is saved as Hollow Square_fill.gcode
It took 3 seconds to fill the file.


>>> fill.fillFile()
File Hollow Square.gcode is being filled.
The filled file is saved as Hollow Square_fill.gcode
It took 3 seconds to fill the file.


>>> fill.getFillChainGcode("
( GCode generated by May 8, 2008 slice.py )
( Extruder Initialization )
..
many lines of gcode
..
")


>>> fill.getFillGcode("
( GCode generated by May 8, 2008 slice.py )
( Extruder Initialization )
..
many lines of gcode
..
")
"""

try:
	import psyco
	psyco.full()
except:
	pass
from vec3 import Vec3
import cmath
import cStringIO
import euclidean
import gcodec
import intercircle
import math
import preferences
import slice
import time
import vectorwrite


__author__ = "Enrique Perez (perez_enrique@yahoo.com)"
__date__ = "$Date: 2008/28/04 $"
__license__ = "GPL 3.0"

#fillet should have just amount choice is unneeded, stretch for estimated contraction, one direction for while, split to weave, hex fill, loop inside sparse fill or run along sparse infill
#tower, stretched paths then loops, combine shapes with different fills
#transform, inclined plane, screw, fillet travel as well maybe
#much afterwards make congajure multistep view, maybe simplify paths on top of loops; why?; actually I think we're already doing this
def addAroundClosest( paths, removedEndpointPoint ):
	"Add the closest removed endpoint to the path, with minimal twisting."
	closestDistanceSquared = 999999999.0
	closestPath = None
	closestPointIndex = None
	for path in paths:
		for pointIndex in range( len( path ) ):
			point = path[ pointIndex ]
			distanceSquared = point.distance2( removedEndpointPoint )
			if distanceSquared < closestDistanceSquared:
				closestDistanceSquared = distanceSquared
				closestPath = path
				closestPointIndex = pointIndex
	if closestPath == None:
		return
	if closestPointIndex + 1 == len( closestPath ):
		closestPath.insert( closestPointIndex + 1, removedEndpointPoint )
		return
	if closestPointIndex == 0:
		closestPath.insert( 0, removedEndpointPoint )
		return
	beforePoint = closestPath[ closestPointIndex - 1 ]
	centerPoint = closestPath[ closestPointIndex ]
	afterPoint = closestPath[ closestPointIndex + 1 ]
	beforeSegment = beforePoint.minus( removedEndpointPoint )
	beforeSegment.normalize()
	centerSegment = centerPoint.minus( removedEndpointPoint )
	centerSegment.normalize()
	afterSegment = afterPoint.minus( removedEndpointPoint )
	afterSegment.normalize()
	beforePlaneDot = euclidean.getPlaneDotPlusOne( beforeSegment, centerSegment )
	afterPlaneDot = euclidean.getPlaneDotPlusOne( centerSegment, afterSegment )
	if beforePlaneDot < afterPlaneDot:
		if beforePlaneDot < 2.0:
			closestPath.insert( closestPointIndex, removedEndpointPoint )
		return
	if afterPlaneDot < 2.0:
		closestPath.insert( closestPointIndex + 1, removedEndpointPoint )

def addPath( extrusionWidth, fill, path, rotationPlaneAngle ):
	"Add simplified path to fill."
	planeRotated = euclidean.getPathRoundZAxisByPlaneAngle( rotationPlaneAngle, euclidean.getSimplifiedLoop( path, extrusionWidth ) )
	fill.append( planeRotated )

def addSparseEndpoints( doubleExtrusionWidth, endpoints, fillDensity, fillLine, horizontalSegments, removedEndpoints, surroundingXIntersections ):
	"Add sparse endpoints."
	horizontalEndpoints = horizontalSegments[ fillLine ]
	for segment in horizontalEndpoints:
		addSparseEndpointsFromSegment( doubleExtrusionWidth, endpoints, fillDensity, fillLine, horizontalSegments, removedEndpoints, segment, surroundingXIntersections )

def addSparseEndpointsFromSegment( doubleExtrusionWidth, endpoints, fillDensity, fillLine, horizontalSegments, removedEndpoints, segment, surroundingXIntersections ):
	"Add sparse endpoints from a segment."
	endpointFirstPoint = segment[ 0 ].point
	endpointSecondPoint = segment[ 1 ].point
	shouldFill = fillLine < 1 or fillLine >= len( horizontalSegments ) - 1 or surroundingXIntersections == None
	if fillDensity > 0.0:
		if int( round( round( fillLine * fillDensity ) / fillDensity ) ) == fillLine:
			shouldFill = True
	if endpointFirstPoint.distance( endpointSecondPoint ) < doubleExtrusionWidth:
		shouldFill = True
	if shouldFill:
		endpoints += segment
		return
	if not isSegmentAround( horizontalSegments[ fillLine - 1 ], segment ):
		endpoints += segment
		return
	if not isSegmentAround( horizontalSegments[ fillLine + 1 ], segment ):
		endpoints += segment
		return
	for surroundingIndex in range( 0, len( surroundingXIntersections ), 2 ):
		surroundingXFirst = surroundingXIntersections[ surroundingIndex ]
		surroundingXSecond = surroundingXIntersections[ surroundingIndex + 1 ]
		if euclidean.isSegmentCompletelyInX( segment, surroundingXFirst, surroundingXSecond ):
			removedEndpoints += segment
			return
	endpoints += segment

def addToThreadsFromLoop( extrusionHalfWidthSquared, gcodeType, fillSkein, loop, oldOrderedLocation ):
	"Add to threads from the last location from loop."
	nearestIndex = int( round( euclidean.getNearestDistanceSquaredIndex( oldOrderedLocation, loop ).imag ) )
	loop = euclidean.getAroundLoop( nearestIndex, nearestIndex, loop )
	nearestPoint = euclidean.getNearestPointOnSegment( loop[ 0 ], loop[ 1 ], oldOrderedLocation )
	if nearestPoint.distance2( loop[ 0 ] ) > extrusionHalfWidthSquared and nearestPoint.distance2( loop[ 1 ] ) > extrusionHalfWidthSquared:
		loop = [ nearestPoint ] + loop[ 1 : ] + [ loop[ 0 ] ]
	oldOrderedLocation.setToVec3( loop[ 0 ] )
	gcode = 'M101\nM114'
	if gcodeType != '':
		gcode += ' (' + gcodeType
	fillSkein.addGcodeFromGcodeThread( gcode, loop + [ loop[ 0 ] ] ) # Turn extruder on and indicate that a loop is beginning.

def addToThreadsFromSurroundingLoops( fillSkein, oldOrderedLocation, surroundingLoops ):
	"Add to threads from the last location from surrounding loops."
	remainingSurroundingLoops = surroundingLoops[ : ]
	while len( remainingSurroundingLoops ) > 0:
		transferClosestSurroundingLoop( fillSkein, oldOrderedLocation, remainingSurroundingLoops )

def createFillForSurroundings( surroundingLoops ):
	"Create extra fill loops for surrounding loops."
	for surroundingLoop in surroundingLoops:
		surroundingLoop.createExtraFillLoops()

def fillChainFile( filename = '' ):
	"Fill the slices of a gcode file.  Chain slice the file if it is a GNU TriangulatedSurface file.  If no filename is specified, fill the first unmodified gcode file in this folder."
	if filename == '':
		unmodified = gcodec.getGNUGcode()
		if len( unmodified ) == 0:
			print( "There are no unmodified gcode files in this folder." )
			return
		filename = unmodified[ 0 ]
	startTime = time.time()
	fillPreferences = FillPreferences()
	preferences.readPreferences( fillPreferences )
	print( 'File ' + gcodec.getSummarizedFilename( filename ) + ' is being chain filled.' )
	gcodeText = gcodec.getFileText( filename )
	if gcodeText == '':
		return
	suffixFilename = filename[ : filename.rfind( '.' ) ] + '_fill.gcode'
	gcodec.writeFileText( suffixFilename, getFillChainGcode( gcodeText, fillPreferences ) )
	print( 'The filled file is saved as ' + suffixFilename )
	if fillPreferences.writeSVG.value:
		vectorwrite.writeVectorFile( suffixFilename )
	print( 'It took ' + str( int( round( time.time() - startTime ) ) ) + ' seconds to fill the file.' )

def fillFile( filename = '' ):
	"Fill the slices of a gcode file.  If no filename is specified, fill the first unmodified gcode file in this folder."
	if filename == '':
		unmodified = gcodec.getUnmodifiedGCodeFiles()
		if len( unmodified ) == 0:
			print( "There are no unmodified gcode files in this folder." )
			return
		filename = unmodified[ 0 ]
	startTime = time.time()
	fillPreferences = FillPreferences()
	preferences.readPreferences( fillPreferences )
	print( 'File ' + gcodec.getSummarizedFilename( filename ) + ' is being filled.' )
	gcodeText = gcodec.getFileText( filename )
	if gcodeText == '':
		return
	suffixFilename = filename[ : filename.rfind( '.' ) ] + '_fill.gcode'
	gcodec.writeFileText( suffixFilename, getFillGcode( gcodeText, fillPreferences ) )
	print( 'The filled file is saved as ' + gcodec.getSummarizedFilename( suffixFilename ) )
	if fillPreferences.writeSVG.value:
		vectorwrite.writeVectorFile( suffixFilename )
	print( 'It took ' + str( int( round( time.time() - startTime ) ) ) + ' seconds to fill the file.' )

def getDoubledRoundZ( overhangingSegment, segmentRoundZ ):
	"Get doubled plane angle around z of the overhanging segment."
	endpoint = overhangingSegment[ 0 ]
	roundZ = endpoint.point.dropAxis( 2 ) - endpoint.otherEndpoint.point.dropAxis( 2 )
	roundZ *= segmentRoundZ
	if abs( roundZ ) == 0.0:
		return complex()
	if roundZ.real < 0.0:
		roundZ *= - 1.0
	roundZLength = abs( roundZ )
	roundZ /= roundZLength
	return roundZ * roundZ * roundZLength

def getExtraFillLoops( insideLoops, outsideLoop, radius ):
	"Get extra loops between inside and outside loops."
	slightlyGreaterThanRadius = 1.05 * radius
	extraFillLoops = []
	circleNodes = intercircle.getCircleNodesFromLoop( outsideLoop, slightlyGreaterThanRadius )
	for inside in insideLoops:
		circleNodes += intercircle.getCircleNodesFromLoop( inside, slightlyGreaterThanRadius )
	circleIntersections = intercircle.getCircleIntersectionsFromCircleNodes( circleNodes )
	circleIntersectionLoops = intercircle.getCircleIntersectionLoops( circleIntersections )
	centers = intercircle.getCentersFromIntersectionLoops( circleIntersectionLoops )
	for center in centers:
		inset = intercircle.getInsetFromClockwiseLoop( center, radius )
		if euclidean.isWiddershins( center ) == euclidean.isWiddershins( inset ):
			if isPathInsideLoop( outsideLoop, inset ):
				if not isPathInsideLoops( insideLoops, inset ):
					extraFillLoops.append( inset )
	return extraFillLoops

def getFillChainGcode( gcodeText, fillPreferences = None ):
	"Fill the slices of a gcode text.  Chain fill the gcode if it is not already sliced."
	if not gcodec.isProcedureDone( gcodeText, 'slice' ):
		gcodeText = slice.getSliceGcode( gcodeText )
	return getFillGcode( gcodeText, fillPreferences )

def getFillGcode( gcodeText, fillPreferences = None ):
	"Fill the slices of a gcode text."
	if gcodeText == '':
		return ''
	if gcodec.isProcedureDone( gcodeText, 'fill' ):
		return gcodeText
	if fillPreferences == None:
		fillPreferences = FillPreferences()
		preferences.readPreferences( fillPreferences )
	skein = FillSkein()
	skein.parseGcode( fillPreferences, gcodeText )
	return skein.output.getvalue()

def getFillOfSurroundings( surroundingLoops ):
	"Get extra fill loops of surrounding loops."
	fillSurroundings = []
	for surroundingLoop in surroundingLoops:
		fillSurroundings += surroundingLoop.getFillLoops()
	return fillSurroundings

def getHorizontalSegments( fillLoops, alreadyFilledArounds, y ):
	"Get horizontal segments inside loops."
	solidXIntersectionList = []
	euclidean.addXIntersectionsFromLoops( fillLoops, - 1, solidXIntersectionList, y )
	for alreadyFilledAroundIndex in range( len( alreadyFilledArounds ) ):
		alreadyFilledLoops = alreadyFilledArounds[ alreadyFilledAroundIndex ]
		for alreadyFilledLoopIndex in range( len( alreadyFilledLoops ) ):
			alreadyFilledLoop = alreadyFilledLoops[ alreadyFilledLoopIndex ]
			euclidean.addXIntersections( alreadyFilledLoop, alreadyFilledAroundIndex, solidXIntersectionList, y )
	return getSegmentsFromIntersections( solidXIntersectionList, y, fillLoops[ 0 ][ 0 ].z )

def getInsidesAddToOutsides( loops, outsides ):
	"Add loops to either the insides or outsides."
	insides = []
	for loopIndex in range( len( loops ) ):
		loop = loops[ loopIndex ]
		if isInsideOtherLoops( loopIndex, loops ):
			insides.append( loop )
		else:
			outsides.append( loop )
	return insides

def getOverhangDirection( belowOutsetLoops, segmentBegin, segmentEnd ):
	"Add to span direction from the endpoint segments which overhang the layer below."
	segment = segmentEnd.minus( segmentBegin )
	normalizedSegment = complex( segment.x, segment.y )
	normalizedSegment /= abs( normalizedSegment )
	segmentYMirror = complex( normalizedSegment.real, - normalizedSegment.imag )
	segmentBegin = euclidean.getRoundZAxisByPlaneAngle( segmentYMirror, segmentBegin )
	segmentEnd = euclidean.getRoundZAxisByPlaneAngle( segmentYMirror, segmentEnd )
	solidXIntersectionList = []
	y = segmentBegin.y
	solidXIntersectionList.append( complex( segmentBegin.x, - 1.0 ) )
	solidXIntersectionList.append( complex( segmentEnd.x, - 1.0 ) )
	for belowLoopIndex in range( len( belowOutsetLoops ) ):
		belowLoop = belowOutsetLoops[ belowLoopIndex ]
		rotatedOutset = euclidean.getPathRoundZAxisByPlaneAngle( segmentYMirror, belowLoop )
		euclidean.addXIntersections( rotatedOutset, belowLoopIndex, solidXIntersectionList, y )
	overhangingSegments = getSegmentsFromIntersections( solidXIntersectionList, y, segmentBegin.z )
	overhangDirection = complex()
	for overhangingSegment in overhangingSegments:
		overhangDirection += getDoubledRoundZ( overhangingSegment, normalizedSegment )
	return overhangDirection

def getSegmentsFromIntersections( solidXIntersectionList, y, z ):
	"Get endpoint segments from the intersections."
	segments = []
	xIntersectionList = []
	fill = False
	solid = False
	solidTable = {}
	solidXIntersectionList.sort( euclidean.compareSolidXByX )
	for solidX in solidXIntersectionList:
		solidXYInteger = int( solidX.imag )
		if solidXYInteger >= 0:
			toggleHashtable( solidTable, solidXYInteger, "" )
		else:
			fill = not fill
		oldSolid = solid
		solid = ( len( solidTable ) == 0 and fill )
		if oldSolid != solid:
			xIntersectionList.append( solidX.real )
	for xIntersectionIndex in range( 0, len( xIntersectionList ), 2 ):
		firstX = xIntersectionList[ xIntersectionIndex ]
		secondX = xIntersectionList[ xIntersectionIndex + 1 ]
		endpointFirst = Endpoint()
		endpointSecond = Endpoint().getFromOtherPoint( endpointFirst, Vec3().getFromXYZ( secondX, y, z ) )
		endpointFirst.getFromOtherPoint( endpointSecond, Vec3().getFromXYZ( firstX, y, z ) )
		segment = ( endpointFirst, endpointSecond )
		segments.append( segment )
	return segments

def getSurroundingLoops( extrusionWidth, loops ):
	"Get surrounding loops from loops."
	outsides = []
	insides = getInsidesAddToOutsides( loops, outsides )
	surroundingLoops = []
	for outside in outsides:
		surroundingLoops.append( SurroundingLoop().getFromInsides( extrusionWidth, insides, outside ) )
	return surroundingLoops

def getSurroundingXIntersections( alreadyFilledSize, doubleSolidSurfaceThickness, surroundingSlices, y ):
	"Get x intersections from surrounding layers."
	if len( surroundingSlices ) < doubleSolidSurfaceThickness:
		return None
	joinedX = []
	solidXIntersectionList = []
	for surroundingIndex in range( len( surroundingSlices ) ):
		surroundingSlice = surroundingSlices[ surroundingIndex ]
		euclidean.addXIntersectionsFromLoops( surroundingSlice, surroundingIndex, joinedX, y )
	solidTable = {}
	solid = False
	joinedX.sort( euclidean.compareSolidXByX )
	for solidX in joinedX:
		solidXYInteger = int( solidX.imag )
		toggleHashtable( solidTable, solidXYInteger, "" )
		oldSolid = solid
		solid = len( solidTable ) >= doubleSolidSurfaceThickness
		if oldSolid != solid:
			solidXIntersectionList.append( solidX.real )
	return solidXIntersectionList

def getTransferredPaths( insides, loop ):
	"Get transferred paths from inside paths."
	transferredPaths = []
	for insideIndex in range( len( insides ) - 1, - 1, - 1 ):
		inside = insides[ insideIndex ]
		if isPathInsideLoop( loop, inside ):
			transferredPaths.append( inside )
			del insides[ insideIndex ]
	return transferredPaths

def isInsideOtherLoops( loopIndex, loops ):
	"Determine if a loop in a list is inside another loop in that list."
	return isPathInsideLoops( loops[ : loopIndex ] + loops[ loopIndex + 1 : ], loops[ loopIndex ] )

def isPathInsideLoop( loop, path ):
	"Determine if a path is inside another loop."
	leftPoint = euclidean.getLeftPoint( path )
	return euclidean.getNumberOfIntersectionsToLeft( leftPoint, loop ) % 2 == 1

def isPathInsideLoops( loops, path ):
	"Determine if a path is inside another loop in a list."
	for loop in loops:
		if isPathInsideLoop( loop, path ):
			return True
	return False

def isSegmentAround( aroundSegments, segment ):
	"Determine if there is another segment around."
	for aroundSegment in aroundSegments:
		endpoint = aroundSegment[ 0 ]
		if isSegmentInX( segment, endpoint.point.x, endpoint.otherEndpoint.point.x ):
			return True
	return False

def isSegmentInX( segment, xFirst, xSecond ):
	"Determine if the segment overlaps within x."
	segmentFirstX = segment[ 0 ].point.x
	segmentSecondX = segment[ 1 ].point.x
	if min( segmentFirstX, segmentSecondX ) > max( xFirst, xSecond ):
		return False
	return max( segmentFirstX, segmentSecondX ) > min( xFirst, xSecond )

def toggleHashtable( hashtable, key, value ):
	"Toggle a hashtable between having and not having a key."
	if key in hashtable:
		del hashtable[ key ]
	else:
		hashtable[ key ] = value

def transferClosestFillLoop( extrusionHalfWidthSquared, fillSkein, oldOrderedLocation, remainingFillLoops ):
	"Transfer the closest remaining fill loop."
	closestDistanceSquared = 999999999999999999.0
	closestFillLoop = None
	for remainingFillLoop in remainingFillLoops:
		distanceSquared = euclidean.getNearestDistanceSquaredIndex( oldOrderedLocation, remainingFillLoop ).real
		if distanceSquared < closestDistanceSquared:
			closestDistanceSquared = distanceSquared
			closestFillLoop = remainingFillLoop
	remainingFillLoops.remove( closestFillLoop )
	addToThreadsFromLoop( extrusionHalfWidthSquared, '', fillSkein, closestFillLoop[ : ], oldOrderedLocation )

def transferClosestPath( fillSkein, oldOrderedLocation, remainingPaths ):
	"Transfer the closest remaining path."
	closestDistanceSquared = 999999999999999999.0
	closestPath = None
	for remainingPath in remainingPaths:
		distanceSquared = min( oldOrderedLocation.distance2( remainingPath[ 0 ] ), oldOrderedLocation.distance2( remainingPath[ - 1 ] ) )
		if distanceSquared < closestDistanceSquared:
			closestDistanceSquared = distanceSquared
			closestPath = remainingPath
	remainingPaths.remove( closestPath )
	if oldOrderedLocation.distance2( closestPath[ - 1 ] ) < oldOrderedLocation.distance2( closestPath[ 0 ] ):
		closestPath.reverse()
	fillSkein.addGcodeFromGcodeThread( 'M101', closestPath ) # Turn extruder on.
	oldOrderedLocation.setToVec3( closestPath[ - 1 ] )

def transferClosestSurroundingLoop( fillSkein, oldOrderedLocation, remainingSurroundingLoops ):
	"Transfer the closest remaining surrounding loop."
	closestDistanceSquared = 999999999999999999.0
	closestSurroundingLoop = None
	for remainingSurroundingLoop in remainingSurroundingLoops:
		distanceSquared = euclidean.getNearestDistanceSquaredIndex( oldOrderedLocation, remainingSurroundingLoop.loop ).real
		if distanceSquared < closestDistanceSquared:
			closestDistanceSquared = distanceSquared
			closestSurroundingLoop = remainingSurroundingLoop
	remainingSurroundingLoops.remove( closestSurroundingLoop )
	closestLoop = closestSurroundingLoop.loop
	closestSurroundingLoop.addToThreads( fillSkein, oldOrderedLocation )

def transferPathsToSurroundingLoops( paths, surroundingLoops ):
	"Transfer paths surrounding loops."
	for surroundingLoop in surroundingLoops:
		surroundingLoop.transferPaths( paths )


class Endpoint:
	"The endpoint of a segment."
	def __repr__( self ):
		"Get the string representation of this Endpoint."
		return 'Endpoint ' + str( self.point ) + ' ' + str( self.otherEndpoint.point )

	def getFromOtherPoint( self, otherEndpoint, point ):
		"Initialize from other endpoint."
		self.otherEndpoint = otherEndpoint
		self.point = point
		return self

	def getNearestEndpoint( self, endpoints ):
		"Get nearest endpoint."
		smallestDistanceSquared = 999999999999999999.0
		nearestEndpoint = None
		for endpoint in endpoints:
			distanceSquared = self.point.distance2( endpoint.point )
			if distanceSquared < smallestDistanceSquared:
				smallestDistanceSquared = distanceSquared
				nearestEndpoint = endpoint
		return nearestEndpoint

	def getNearestMiss( self, arounds, endpoints, extrusionWidth, path, stretchedXSegments ):
		"Get the nearest endpoint which the segment to that endpoint misses the other extrusions."
		smallestDistanceSquared = 999999999999999999.0
		nearestMiss = None
		normalizedPenultimateMinusLastX = - 1.0
		if len( path ) > 1:
			if path[ - 2 ].x > self.point.x:
				normalizedPenultimateMinusLastX = 1.0
		for endpoint in endpoints:
			segment = endpoint.point.minus( self.point )
			normalizedSegment = complex( segment.x, segment.y )
			normalizedSegment /= abs( normalizedSegment )
			segmentYMirror = complex( normalizedSegment.real, - normalizedSegment.imag )
			segmentFirstPoint = euclidean.getRoundZAxisByPlaneAngle( segmentYMirror, self.point )
			segmentSecondPoint = euclidean.getRoundZAxisByPlaneAngle( segmentYMirror, endpoint.point )
			distanceSquared = self.point.distance2( endpoint.point )
			if distanceSquared < smallestDistanceSquared:
				if not self.isLoopListCrossingInsideXSegment( arounds, segmentFirstPoint.x, segmentSecondPoint.x, segmentYMirror, segmentFirstPoint.y ):
					if not self.isPointCrossingSegments( extrusionWidth, endpoint.point, stretchedXSegments ):
						if normalizedPenultimateMinusLastX * normalizedSegment.real < 0.8:
							smallestDistanceSquared = distanceSquared
							nearestMiss = endpoint
		return nearestMiss

	def isLoopListCrossingInsideXSegment( self, loopList, segmentFirstX, segmentSecondX, segmentYMirror, y ):
		"Determine if the loop list is crossing inside the x segment."
		for alreadyFilledLoop in loopList:
			loop = euclidean.getPathRoundZAxisByPlaneAngle( segmentYMirror, alreadyFilledLoop )
			for pointIndex in range( len( loop ) ):
				pointFirst = loop[ pointIndex ]
				pointSecond = loop[ ( pointIndex + 1 ) % len( loop ) ]
				if euclidean.isLineCrossingInsideXSegment( segmentFirstX, segmentSecondX, pointFirst, pointSecond, y ):
					return True
		return False

	def isPointCrossingSegments( self, extrusionWidth, inputPoint, stretchedXSegments ):
		"Determine if the segment to the point is crossing a stretched x segment."
		endpointRadius = 0.1 * extrusionWidth
		segment = inputPoint.minus( self.point )
		alongSegmentLength = 0.333 * segment.length()
		segment.scale( alongSegmentLength / segment.length() )
		attractedPoint = self.point.plus( segment )
		attractedInputPoint = inputPoint.minus( segment )
		for stretchedXSegment in stretchedXSegments:
			if euclidean.isLineCrossingInsideXSegment( stretchedXSegment.xMinimum, stretchedXSegment.xMaximum, attractedPoint, attractedInputPoint, stretchedXSegment.y ):
				return True
		return False


class FillSkein:
	"A class to fill a skein of extrusions."
	def __init__( self ):
		self.extruderActive = False
		self.lastExtraShells = - 1
		self.layer = None
		self.layers = []
		self.lineIndex = 0
		self.oldLocation = None
		self.oldOrderedLocation = Vec3()
		self.output = cStringIO.StringIO()
		self.spanDirections = []
		self.thread = None

	def addFill( self, layerIndex ):
		"Add fill to the slice layer."
		alreadyFilledArounds = []
		arounds = []
		back = - 999999999.0
		doubleExtrusionWidth = 2.0 * self.extrusionWidth
		endpoints = []
		fill = []
		fillEdgeIndex = 0
		aroundInset = 0.7 * self.fillInset
		front = 999999999.0
		halfFillInset = 0.5 * self.fillInset
		layer = self.layers[ layerIndex ]
		slightlyGreaterThanFill = 1.01 * self.fillInset
		layerRotationAroundZAngle = self.getLayerRoundZ( layerIndex )
		reverseRotationAroundZAngle = complex( layerRotationAroundZAngle.real, - layerRotationAroundZAngle.imag )
		rotatedExtruderLoops = []
		stretch = 0.1 * self.extrusionWidth
		loops = []
		for thread in layer:
			loops.append( thread[ 1 : ] )
		surroundingSlices = []
		layerRemainder = layerIndex % int( round( self.fillPreferences.diaphragmPeriod.value ) )
		if layerRemainder >= int( round( self.fillPreferences.diaphragmThickness.value ) ):
			for surroundingIndex in range( 1, self.solidSurfaceThickness + 1 ):
				self.addRotatedSlice( layerIndex - surroundingIndex, reverseRotationAroundZAngle, surroundingSlices )
				self.addRotatedSlice( layerIndex + surroundingIndex, reverseRotationAroundZAngle, surroundingSlices )
		extraShells = self.fillPreferences.extraShellsSparseLayer.value
		if len( surroundingSlices ) < self.doubleSolidSurfaceThickness:
			if self.lastExtraShells != self.fillPreferences.extraShellsBase.value:
				extraShells = self.fillPreferences.extraShellsBase.value
		self.lastExtraShells = extraShells
		surroundingLoops = getSurroundingLoops( self.extrusionWidth, loops )
		for extraShellIndex in range( extraShells ):
			createFillForSurroundings( surroundingLoops )
		fillLoops = getFillOfSurroundings( surroundingLoops )
		for loop in fillLoops:
			alreadyFilledLoop = []
			alreadyFilledArounds.append( alreadyFilledLoop )
			planeRotatedPerimeter = euclidean.getPathRoundZAxisByPlaneAngle( reverseRotationAroundZAngle, loop )
			alreadyFilledLoop.append( planeRotatedPerimeter )
			centers = intercircle.getCentersfromLoopDirection( euclidean.isWiddershins( planeRotatedPerimeter ), planeRotatedPerimeter, slightlyGreaterThanFill )
			for center in centers:
				inset = intercircle.getInsetFromClockwiseLoop( center, self.fillInset )
				if euclidean.isWiddershins( center ) == euclidean.isWiddershins( inset ):
					around = intercircle.getInsetFromClockwiseLoop( center, aroundInset )
					rotatedExtruderLoops.append( intercircle.getInsetFromClockwiseLoop( center, halfFillInset ) )
					alreadyFilledLoop.append( inset )
					arounds.append( around )
					for point in inset:
						back = max( back, point.y )
						front = min( front, point.y )
		fillWidth = back - front
		numberOfIntervals = int( math.floor( fillWidth / self.extrusionWidth ) )
		fillRemainder = fillWidth - float( numberOfIntervals ) * self.extrusionWidth
		halfFillRemainder = 0.5 * fillRemainder
		back -= halfFillRemainder
		front += halfFillRemainder
		horizontalSegments = []
		for fillLine in range( numberOfIntervals + 1 ):
			y = front + float( fillLine ) * self.extrusionWidth
			lineSegments = getHorizontalSegments( rotatedExtruderLoops, alreadyFilledArounds, y )
			horizontalSegments.append( lineSegments )
		removedEndpoints = []
		for fillLine in range( len( horizontalSegments ) ):
			y = front + float( fillLine ) * self.extrusionWidth
			horizontalEndpoints = horizontalSegments[ fillLine ]
			surroundingXIntersections = getSurroundingXIntersections( len( alreadyFilledArounds ), self.doubleSolidSurfaceThickness, surroundingSlices, y )
			addSparseEndpoints( doubleExtrusionWidth, endpoints, self.fillDensity, fillLine, horizontalSegments, removedEndpoints, surroundingXIntersections )
		if len( endpoints ) < 1:
			return
		stretchedXSegments = []
		for beginningEndpoint in endpoints[ : : 2 ]:
			beginningPoint = beginningEndpoint.point
			stretchedXSegment = StretchedXSegment().getFromXYStretch( beginningPoint.x, beginningPoint.y, beginningEndpoint.otherEndpoint.point.x, stretch )
			stretchedXSegments.append( stretchedXSegment )
		endpointFirst = endpoints[ 0 ]
		endpoints.remove( endpointFirst )
		otherEndpoint = endpointFirst.otherEndpoint
		endpoints.remove( otherEndpoint )
		nextEndpoint = None
		path = []
		paths = []
		if len( endpoints ) > 1:
			nextEndpoint = otherEndpoint.getNearestMiss( arounds, endpoints, self.extrusionWidth, path, stretchedXSegments )
			if nextEndpoint != None:
				if nextEndpoint.point.distance2( endpointFirst.point ) < nextEndpoint.point.distance2( otherEndpoint.point ):
					endpointFirst = endpointFirst.otherEndpoint
					otherEndpoint = endpointFirst.otherEndpoint
		path.append( endpointFirst.point )
		path.append( otherEndpoint.point )
		while len( endpoints ) > 1:
			nextEndpoint = otherEndpoint.getNearestMiss( arounds, endpoints, self.extrusionWidth, path, stretchedXSegments )
			if nextEndpoint == None:
				paths.append( path )
				path = []
				nextEndpoint = otherEndpoint.getNearestEndpoint( endpoints )
			path.append( nextEndpoint.point )
			endpoints.remove( nextEndpoint )
			otherEndpoint = nextEndpoint.otherEndpoint
			path.append( otherEndpoint.point )
			endpoints.remove( otherEndpoint )
		paths.append( path )
		for removedEndpoint in removedEndpoints:
			addAroundClosest( paths, removedEndpoint.point )
		for path in paths:
			addPath( self.extrusionWidth, fill, path, layerRotationAroundZAngle )
		transferPathsToSurroundingLoops( fill, surroundingLoops )
		self.addLine( '( Extruder paths for layer ' + str( layerIndex ) + ' )' ) # GCode formatted comment
		self.addLine( 'M113 (' + str( layerIndex ) ) # Indicate that a new layer is starting.
		addToThreadsFromSurroundingLoops( self, self.oldOrderedLocation, surroundingLoops )

	def addGcodeMovement( self, point ):
		"Add a movement to the output."
		self.lastOutputPoint = point
		self.output.write( "G1 X" + euclidean.getRoundedToThreePlaces( point.x ) + " Y" + euclidean.getRoundedToThreePlaces( point.y ) )
		self.addLine( " Z" + euclidean.getRoundedToThreePlaces( point.z ) + " F" + euclidean.getRoundedToThreePlaces( self.feedratePerMinute ) )

	def addGcodeFromGcodeThread( self, gcode, thread ):
		"Add a gcode thread to the output."
		if len( thread ) > 0:
			self.addGcodeMovement( thread[ 0 ] )
		else:
			print( "zero length vertex positions array which was skipped over, this should never happen" )
		if len( thread ) < 2:
			return
		self.addLine( gcode )
		for point in thread[ 1 : ]:
			self.addGcodeMovement( point )
		self.addLine( "M103" ) # Turn extruder off.

	def addLine( self, line ):
		"Add a line of text and a newline to the output."
		self.output.write( line + "\n" )

	def addRotatedSlice( self, layerIndex, reverseRotationAroundZAngle, surroundingSlices ):
		"Add a rotated slice to the surrounding slices."
		if layerIndex < 0 or layerIndex >= len( self.layers ):
			return
		layer = self.layers[ layerIndex ]
		rotatedSlice = []
		for thread in layer:
			planeRotatedLoop = euclidean.getPathRoundZAxisByPlaneAngle( reverseRotationAroundZAngle, thread[ 1 : ] )
			rotatedSlice.append( planeRotatedLoop )
		surroundingSlices.append( rotatedSlice )

	def addShutdownToOutput( self ):
		"Add shutdown gcode to the output."
		self.addLine( '( Extruder Shut Down )' ) # GCode formatted comment
		self.addLine( "M103" ) # Turn extruder off.

	def addSpanDirection( self, layerIndex ):
		"Get span direction for the majority of the overhanging extrusion perimeter, if any."
		if not self.fillPreferences.fillPerpendicularSpan.value:
			self.spanDirections.append( None )
			return
		belowIndex = layerIndex - 1
		if belowIndex < 0:
			self.spanDirections.append( None )
			return
		belowOutsetLoops = []
		overhangInset = 1.25 * self.extrusionWidth
		greaterThanOverhang = 1.1 * overhangInset
		for thread in self.layers[ belowIndex ]:
			loop = thread[ 1 : ]
			centers = intercircle.getCentersfromLoopDirection( not euclidean.isWiddershins( loop ), loop, greaterThanOverhang )
			for center in centers:
				outset = intercircle.getInsetFromClockwiseLoop( center, overhangInset )
				if euclidean.isWiddershins( center ) == euclidean.isWiddershins( outset ):
					if euclidean.getMaximumSpan( outset ) > self.fillInset:
						belowOutsetLoops.append( outset )
		spanDirection = complex()
		for thread in self.layers[ layerIndex ]:
			for pointIndex in range( 1, len( thread ) ):
				spanDirection += getOverhangDirection( belowOutsetLoops, thread[ pointIndex - 1 ], thread[ pointIndex ] )
#		print( spanDirection )
		if abs( spanDirection ) < self.halfExtrusionWidth:
			self.spanDirections.append( None )
		else:
			spanDirection /= abs( spanDirection )
			self.spanDirections.append( cmath.sqrt( spanDirection ) )

	def addToThread( self, location ):
		"Add a location to thread."
		if self.oldLocation == None:
			return
		if self.layer == None:
			self.layer = []
			self.layers.append( self.layer )
		if self.thread == None:
			self.thread = [ self.oldLocation ]
			self.layer.append( self.thread )
		self.thread.append( location )

	def getLayerRoundZ( self, layerIndex ):
		"Get the plane angle around z that the layer is rotated by."
		if self.spanDirections[ layerIndex ] != None:
			return self.spanDirections[ layerIndex ]
		return euclidean.getPolar( self.fillBeginRotation + float( ( layerIndex % 2 ) * self.fillOddLayerExtraRotation ), 1.0 )

	def linearMove( self, splitLine ):
		"Add a linear move to the thread."
		location = gcodec.getLocationFromSplitLine( self.oldLocation, splitLine )
		if self.extruderActive:
			self.addToThread( location )
		self.oldLocation = location

	def parseGcode( self, fillPreferences, gcodeText ):
		"Parse gcode text and store the bevel gcode."
		self.fillPreferences = fillPreferences
		self.lines = gcodec.getTextLines( gcodeText )
		self.parseInitialization()
		self.feedratePerMinute = 60.0 * fillPreferences.feedratePerSecond.value
		self.fillDensity = fillPreferences.fillDensity.value
		self.fillBeginRotation = math.radians( fillPreferences.fillBeginRotation.value )
		self.fillOddLayerExtraRotation = math.radians( fillPreferences.fillOddLayerExtraRotation.value )
		self.solidSurfaceThickness = int( round( self.fillPreferences.solidSurfaceThickness.value ) )
		self.doubleSolidSurfaceThickness = self.solidSurfaceThickness + self.solidSurfaceThickness
		for line in self.lines[ self.lineIndex : ]:
			self.parseLine( line )
		for layerIndex in range( len( self.layers ) ):
			self.addSpanDirection( layerIndex )
		for layerIndex in range( len( self.layers ) ):
			self.addFill( layerIndex )
		self.addShutdownToOutput()

	def parseInitialization( self ):
		"Parse gcode initialization and store the parameters."
		for self.lineIndex in range( len( self.lines ) ):
			line = self.lines[ self.lineIndex ]
			splitLine = line.split( ' ' )
			firstWord = ''
			if len( splitLine ) > 0:
				firstWord = splitLine[ 0 ]
			if firstWord == 'M109':
				self.extrusionWidth = gcodec.getDoubleAfterFirstLetter( splitLine[ 1 ] )
				self.halfExtrusionWidth = 0.5 * self.extrusionWidth
				self.absoluteFillPerimeterOverlap = self.halfExtrusionWidth * ( 1.0 - self.fillPreferences.fillPerimeterOverlap.value )
				self.fillInset = self.halfExtrusionWidth + self.absoluteFillPerimeterOverlap
				self.addLine( 'M115 (' + str( self.fillInset ) ) # Set fill inset.
			elif firstWord == 'M112':
				self.addLine( 'M111 (fill)' )
				self.addLine( line )
				return
			self.addLine( line )

	def parseLine( self, line ):
		"Parse a gcode line and add it to the fill skein."
		splitLine = line.split( ' ' )
		if len( splitLine ) < 1:
			return
		firstWord = splitLine[ 0 ]
		if firstWord == 'G1':
			self.linearMove( splitLine )
		elif firstWord == 'M101':
			self.extruderActive = True
		elif firstWord == 'M103':
			self.extruderActive = False
			self.thread = None
		elif firstWord == 'M113':
			self.layer = None
			self.thread = None


class FillPreferences:
	"A class to handle the fill preferences."
	def __init__( self ):
		"Set the default preferences, execute title & preferences filename."
		#Set the default preferences.
		self.diaphragmPeriod = preferences.IntPreference().getFromValue( 'Diaphragm Period (layers):', 9 )
		self.diaphragmThickness = preferences.IntPreference().getFromValue( 'Diaphragm Thickness (layers):', 3 )
		self.extraShellsBase = preferences.IntPreference().getFromValue( 'Extra Shells on Base (layers):', 0 )
		self.extraShellsSparseLayer = preferences.IntPreference().getFromValue( 'Extra Shells on Sparse Layer (layers):', 1 )
		self.feedratePerSecond = preferences.FloatPreference().getFromValue( 'Feedrate (mm/s):', 10.0 )
		self.filenameInput = preferences.Filename().getFromFilename( [ ( 'GNU Triangulated Surface text files', '*.gts' ), ( 'Gcode text files', '*.gcode' ) ], 'Open File to be Filled', '' )
		self.fillBeginRotation = preferences.FloatPreference().getFromValue( 'Fill Begin Rotation (degrees):', 45.0 )
		self.fillDensity = preferences.FloatPreference().getFromValue( 'Fill Density (ratio):', 0.5 )
		self.fillOddLayerExtraRotation = preferences.FloatPreference().getFromValue( 'Fill Odd Layer Extra Rotation (degrees):', 90.0 )
		self.fillPerimeterOverlap = preferences.FloatPreference().getFromValue( 'Fill Perimeter Overlap (ratio):', 0.1 )
		self.fillPerpendicularSpan = preferences.BooleanPreference().getFromValue( 'Fill Perpendicular to Overhanging Spans:', True )
		self.solidSurfaceThickness = preferences.IntPreference().getFromValue( 'Solid Surface Thickness (layers):', 2 )
		self.writeSVG = preferences.BooleanPreference().getFromValue( 'Write Scalable Vector Graphics:', True )
		directoryRadio = []
		self.directoryPreference = preferences.RadioLabel().getFromRadioLabel( 'Fill All Unmodified Files in a Directory', 'File or Directory Choice:', directoryRadio, False )
		self.filePreference = preferences.Radio().getFromRadio( 'Fill File', directoryRadio, True )
		#Create the archive, title of the execute button, title of the dialog & preferences filename.
		self.archive = [
			self.diaphragmPeriod,
			self.diaphragmThickness,
			self.extraShellsBase,
			self.extraShellsSparseLayer,
			self.feedratePerSecond,
			self.filenameInput,
			self.fillBeginRotation,
			self.fillDensity,
			self.fillOddLayerExtraRotation,
			self.fillPerimeterOverlap,
			self.fillPerpendicularSpan,
			self.solidSurfaceThickness,
			self.writeSVG,
			self.directoryPreference,
			self.filePreference ]
		self.executeTitle = 'Fill'
#		self.filename = getPreferencesFilePath( 'fill.csv' )
		self.filenamePreferences = 'fill.csv'
		self.filenameHelp = 'fill.html'
		self.title = 'Fill Preferences'

	def execute( self ):
		"Fill button has been clicked."
		filenames = gcodec.getGcodeDirectoryOrFile( self.directoryPreference.value, self.filenameInput.value, self.filenameInput.wasCancelled )
		for filename in filenames:
			fillChainFile( filename )


class SurroundingLoop:
	"A loop that surrounds paths."
	def __repr__( self ):
		"Get the string representation of this surrounding loop."
		return '%s, %s, %s' % ( self.loop, self.innerSurroundings, self.paths )

	def addToThreads( self, fillSkein, oldOrderedLocation ):
		"Add to paths from the last location."
		addToThreadsFromLoop( self.extrusionHalfWidthSquared, 'edge', fillSkein, self.loop[ : ], oldOrderedLocation )
		addToThreadsFromSurroundingLoops( fillSkein, oldOrderedLocation, self.innerSurroundings )
		if self.lastFillLoops != None:
			remainingFillLoops = self.lastFillLoops[ : ]
			while len( remainingFillLoops ) > 0:
				transferClosestFillLoop( self.extrusionHalfWidthSquared, fillSkein, oldOrderedLocation, remainingFillLoops )
		remainingPaths = self.paths[ : ]
		while len( remainingPaths ) > 0:
			transferClosestPath( fillSkein, oldOrderedLocation, remainingPaths )

	def createExtraFillLoops( self ):
		"Create extra fill loops."
		outsides = []
		insides = getInsidesAddToOutsides( self.getLoopsToBeFilled(), outsides )
		self.lastFillLoops = []
		for outside in outsides:
			transferredLoops = getTransferredPaths( insides, outside )
			self.lastFillLoops += getExtraFillLoops( transferredLoops, outside, self.extrusionWidth )
		self.extraLoops += self.lastFillLoops
		for surroundingLoop in self.innerSurroundings:
			createFillForSurroundings( surroundingLoop.innerSurroundings )

	def getFillLoops( self ):
		"Get last fill loops from the outside loop and the loops inside the inside loops."
		fillLoops = self.getLoopsToBeFilled()[ : ]
		for surroundingLoop in self.innerSurroundings:
			fillLoops += getFillOfSurroundings( surroundingLoop.innerSurroundings )
		return fillLoops

	def getFromInsides( self, extrusionWidth, inputInsides, loop ):
		"Initialize from inside loops."
		self.extraLoops = []
		self.extrusionHalfWidthSquared = 0.25 * extrusionWidth * extrusionWidth
		self.extrusionWidth = extrusionWidth
		self.loop = loop
		transferredLoops = getTransferredPaths( inputInsides, loop )
		self.innerSurroundings = getSurroundingLoops( extrusionWidth, transferredLoops )
		self.lastFillLoops = None
		return self

	def getLoopsToBeFilled( self ):
		"Get last fill loops from the outside loop and the loops inside the inside loops."
		if self.lastFillLoops != None:
			return self.lastFillLoops
		loopsToBeFilled = [ self.loop ]
		for surroundingLoop in self.innerSurroundings:
			loopsToBeFilled.append( surroundingLoop.loop )
		return loopsToBeFilled

	def transferPaths( self, paths ):
		"Transfer paths."
		transferPathsToSurroundingLoops( paths, self.innerSurroundings )
		self.paths = getTransferredPaths( paths, self.loop )


class StretchedXSegment:
	"A stretched x segment."
	def __repr__( self ):
		"Get the string representation of this StretchedXSegment."
		return str( self.xMinimum ) + ' ' + str( self.xMaximum ) + ' ' + str( self.y )

	def getFromXYStretch( self, firstX, y, secondX, stretch ):
		"Initialize from x, y, and stretch."
		self.xMaximum = max( firstX, secondX ) + stretch
		self.xMinimum = min( firstX, secondX ) - stretch
		self.y = y
		return self


def main( hashtable = None ):
	"Display the fill dialog."
	preferences.displayDialog( FillPreferences() )

if __name__ == "__main__":
	main()
