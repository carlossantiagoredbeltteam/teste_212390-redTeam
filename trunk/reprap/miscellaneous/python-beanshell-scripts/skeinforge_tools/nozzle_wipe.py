"""
Nozzle wipe is a script to wipe the nozzle.

At the beginning of a layer, depending on the preferences nozzle, wipe will move the nozzle with the extruder off to the arrival point,
then to the wipe point, then to the departure point, then back to the layer.

The default 'Activate Nozzle Wipe' checkbox is on.  When it is on, the functions described below will work, when it is off, the functions
will not be called.

The "Location Arrival X" preference, is the x coordinate of the arrival location.  The "Location Arrival Y" and "Location Arrival Z"
preferences are the y & z coordinates of the location.  The equivalent "Location Wipe.." and "Location Departure.." preferences are for
the wipe and departure locations.

The "Nozzle Wipe Period (layers)" preference is the number of layers between nozzle wipes.  Nozzle wipe will always wipe just before
the first layer, afterwards it will wipe every "Nozzle Wipe Period" layers.  With the default of three, nozzle wipe will wipe just before
the zeroth layer, the third layer, sixth layer and so on.

To run nozzle wipe, in a shell which nozzle wipe is in type:
> python nozzle_wipe.py

The following examples nozzle wipes the files Hollow Square.gcode & Hollow Square.gts.  The examples are run in a terminal in the
folder which contains Hollow Square.gcode, Hollow Square.gts and nozzle_wipe.py.  The nozzle wipe function will nozzle wipe if the
'Activate Nozzle Wipe' checkbox is on.  The functions writeOutput and getNozzleWipeChainGcode check to see if the text has been
nozzle wiped, if not they call the getHopChainGcode in hop.py to hop the text; once they have the hopped text, then they nozzle wipe.


> python nozzle_wipe.py
This brings up the dialog, after clicking 'Nozzle Wipe', the following is printed:
File Hollow Square.gts is being chain nozzle wiped.
The nozzle wiped file is saved as Hollow Square_nozzle_wipe.gcode


> python nozzle_wipe.py Hollow Square.gts
File Hollow Square.gts is being chain nozzle wiped.
The nozzle wiped file is saved as Hollow Square_nozzle_wipe.gcode


> python
Python 2.5.1 (r251:54863, Sep 22 2007, 01:43:31)
[GCC 4.2.1 (SUSE Linux)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import nozzle_wipe
>>> nozzle_wipe.main()
This brings up the nozzle wipe dialog.


>>> nozzle_wipe.writeOutput()
File Hollow Square.gts is being chain nozzle wiped.
The nozzle wiped file is saved as Hollow Square_nozzle_wipe.gcode


>>> nozzle_wipe.getNozzleWipeGcode("
( GCode generated by May 8, 2008 slice.py )
( Extruder Initialization )
..
many lines of gcode
..
")
Many line of nozzle wiped gcode.

>>> nozzle_wipe.getNozzleWipeChainGcode("
( GCode generated by May 8, 2008 slice.py )
( Extruder Initialization )
..
many lines of gcode
..
")
Many line of nozzle wiped gcode.

"""

from __future__ import absolute_import
#Init has to be imported first because it has code to workaround the python bug where relative imports don't work if the module is imported as a main module.
import __init__

from skeinforge_tools.skeinforge_utilities import euclidean
from skeinforge_tools.skeinforge_utilities import gcodec
from skeinforge_tools.skeinforge_utilities import preferences
from skeinforge_tools.skeinforge_utilities.vec3 import Vec3
from skeinforge_tools import analyze
from skeinforge_tools import hop
from skeinforge_tools import import_translator
from skeinforge_tools import polyfile
import cStringIO
import math
import sys
import time


__author__ = "Enrique Perez (perez_enrique@yahoo.com)"
__date__ = "$Date: 2008/21/04 $"
__license__ = "GPL 3.0"


def getNozzleWipeChainGcode( filename, gcodeText, nozzleWipePreferences = None ):
	"Nozzle wipe a gcode linear move text.  Chain nozzle wipe the gcode if it is not already nozzle wiped."
	gcodeText = gcodec.getGcodeFileText( filename, gcodeText )
	if not gcodec.isProcedureDone( gcodeText, 'hop' ):
		gcodeText = hop.getHopChainGcode( filename, gcodeText )
	return getNozzleWipeGcode( gcodeText, nozzleWipePreferences )

def getNozzleWipeGcode( gcodeText, nozzleWipePreferences = None ):
	"Nozzle wipe a gcode linear move text."
	if gcodeText == '':
		return ''
	if gcodec.isProcedureDone( gcodeText, 'nozzle_wipe' ):
		return gcodeText
	if nozzleWipePreferences == None:
		nozzleWipePreferences = NozzleWipePreferences()
		preferences.readPreferences( nozzleWipePreferences )
	if not nozzleWipePreferences.activateNozzleWipe.value:
		return gcodeText
	skein = NozzleWipeSkein()
	skein.parseGcode( gcodeText, nozzleWipePreferences )
	return skein.output.getvalue()

def writeOutput( filename = '' ):
	"Nozzle wipe a gcode linear move file.  Chain nozzle wipe the gcode if it is not already nozzle wiped. If no filename is specified, nozzle wipe the first unmodified gcode file in this folder."
	if filename == '':
		unmodified = import_translator.getGNUTranslatorFilesUnmodified()
		if len( unmodified ) == 0:
			print( "There are no unmodified gcode files in this folder." )
			return
		filename = unmodified[ 0 ]
	nozzleWipePreferences = NozzleWipePreferences()
	preferences.readPreferences( nozzleWipePreferences )
	startTime = time.time()
	print( 'File ' + gcodec.getSummarizedFilename( filename ) + ' is being chain nozzle wiped.' )
	suffixFilename = filename[ : filename.rfind( '.' ) ] + '_nozzle_wipe.gcode'
	nozzleWipeGcode = getNozzleWipeChainGcode( filename, '', nozzleWipePreferences )
	if nozzleWipeGcode == '':
		return
	gcodec.writeFileText( suffixFilename, nozzleWipeGcode )
	print( 'The nozzle wiped file is saved as ' + gcodec.getSummarizedFilename( suffixFilename ) )
	analyze.writeOutput( suffixFilename, nozzleWipeGcode )
	print( 'It took ' + str( int( round( time.time() - startTime ) ) ) + ' seconds to nozzle wipe the file.' )


class NozzleWipeSkein:
	"A class to nozzle wipe a skein of extrusions."
	def __init__( self ):
		self.decimalPlacesCarried = 3
		self.extruderActive = False
		self.feedrateMinute = 960.0
		self.highestZ = None
		self.layerIndex = - 1
		self.lineIndex = 0
		self.lines = None
		self.oldLocation = None
		self.output = cStringIO.StringIO()
		self.shouldWipe = False

	def addHop( self, begin, end ):
		"Add hop to highest point."
		beginEndDistance = begin.distance( end )
		if beginEndDistance < 3.0 * self.extrusionWidth:
			return
		alongWay = self.extrusionWidth / beginEndDistance
		closeToOldLocation = euclidean.getIntermediateLocation( alongWay, begin, end )
		closeToOldLocation.z = self.highestZ
		self.addLine( self.getLinearMoveWithFeedrate( self.feedrateMinute, closeToOldLocation ) )
		closeToOldArrival = euclidean.getIntermediateLocation( alongWay, end, begin )
		closeToOldArrival.z = self.highestZ
		self.addLine( self.getLinearMoveWithFeedrate( self.feedrateMinute, closeToOldArrival ) )

	def addLine( self, line ):
		"Add a line of text and a newline to the output."
		self.output.write( line + "\n" )

	def addWipeTravel( self, splitLine ):
		"Add the wipe travel gcode."
		indexOfF = gcodec.indexOfStartingWithSecond( "F", splitLine )
		if indexOfF > 0:
			self.feedrateMinute = float( splitLine[ indexOfF ][ 1 : ] )
		location = gcodec.getLocationFromSplitLine( self.oldLocation, splitLine )
		self.highestZ = max( self.highestZ, location.z )
		if not self.shouldWipe:
			return
		self.shouldWipe = False
		if self.extruderActive:
			self.addLine( 'M103' )
		if self.oldLocation != None:
			self.addHop( self.oldLocation, self.locationArrival )
		self.addLine( self.getLinearMoveWithFeedrate( self.feedrateMinute, self.locationArrival ) )
		arrivalWipeDistance = self.locationArrival.distance( self.locationWipe )
		feedrateOverThree = 0.33333 * self.feedrateMinute
		if arrivalWipeDistance > 2.0 * self.extrusionWidth:
			alongWay = self.extrusionWidth / arrivalWipeDistance
			justBeforeWipeLocation = euclidean.getIntermediateLocation( alongWay, self.locationWipe, self.locationArrival )
			self.addLine( self.getLinearMoveWithFeedrate( feedrateOverThree, justBeforeWipeLocation ) )
		self.addLine( self.getLinearMoveWithFeedrate( self.feedrateMinute, self.locationWipe ) )
		wipeDepartureDistance = self.locationWipe.distance( self.locationDeparture )
		if wipeDepartureDistance > 2.0 * self.extrusionWidth:
			alongWay = self.extrusionWidth / wipeDepartureDistance
			justAfterWipeLocation = euclidean.getIntermediateLocation( alongWay, self.locationWipe, self.locationDeparture )
			self.addLine( self.getLinearMoveWithFeedrate( feedrateOverThree, justAfterWipeLocation ) )
		self.addLine( self.getLinearMoveWithFeedrate( self.feedrateMinute, self.locationDeparture ) )
		self.addHop( self.locationDeparture, location )
		if self.extruderActive:
			self.addLine( 'M101' )

	def getLinearMoveWithFeedrate( self, feedrate, location ):
		"Get a linear move line with the feedrate."
		return 'G1 X%s Y%s Z%s F%s' % ( self.getRounded( location.x ), self.getRounded( location.y ), self.getRounded( location.z ), self.getRounded( feedrate ) )

	def getRounded( self, number ):
		"Get number rounded to the number of carried decimal places as a string."
		return euclidean.getRoundedToDecimalPlaces( self.decimalPlacesCarried, number )

	def parseGcode( self, gcodeText, nozzleWipePreferences ):
		"Parse gcode text and store the nozzle wipe gcode."
		self.lines = gcodec.getTextLines( gcodeText )
		self.nozzleWipePeriod = nozzleWipePreferences.nozzleWipePeriod.value
		self.parseInitialization( nozzleWipePreferences )
		self.locationArrival = Vec3( nozzleWipePreferences.locationArrivalX.value, nozzleWipePreferences.locationArrivalY.value, nozzleWipePreferences.locationArrivalZ.value )
		self.locationDeparture = Vec3( nozzleWipePreferences.locationDepartureX.value, nozzleWipePreferences.locationDepartureY.value, nozzleWipePreferences.locationDepartureZ.value )
		self.locationWipe = Vec3( nozzleWipePreferences.locationWipeX.value, nozzleWipePreferences.locationWipeY.value, nozzleWipePreferences.locationWipeZ.value )
		for self.lineIndex in range( self.lineIndex, len( self.lines ) ):
			line = self.lines[ self.lineIndex ]
			self.parseLine( line )

	def parseInitialization( self, nozzleWipePreferences ):
		"Parse gcode initialization and store the parameters."
		for self.lineIndex in range( len( self.lines ) ):
			line = self.lines[ self.lineIndex ]
			splitLine = line.split()
			firstWord = gcodec.getFirstWord( splitLine )
			if firstWord == '(<decimalPlacesCarried>':
				self.decimalPlacesCarried = int( splitLine[ 1 ] )
			elif firstWord == '(<extrusionStart>':
				self.addLine( '(<procedureDone> nozzle_wipe )' )
				return
			elif firstWord == '(<extrusionWidth>':
				self.extrusionWidth = float( splitLine[ 1 ] )
			self.addLine( line )

	def parseLine( self, line ):
		"Parse a gcode line and add it to the bevel gcode."
		splitLine = line.split()
		if len( splitLine ) < 1:
			return
		firstWord = splitLine[ 0 ]
		if firstWord == 'G1':
			self.addWipeTravel( splitLine )
			self.oldLocation = gcodec.getLocationFromSplitLine( self.oldLocation, splitLine )
		elif firstWord == '(<layerStart>':
			self.layerIndex += 1
			if self.layerIndex % self.nozzleWipePeriod == 0:
				self.shouldWipe = True
		elif firstWord == 'M101':
			self.extruderActive = True
		elif firstWord == 'M103':
			self.extruderActive = False
		self.addLine( line )


class NozzleWipePreferences:
	"A class to handle the nozzle wipe preferences."
	def __init__( self ):
		"Set the default preferences, execute title & preferences filename."
		#Set the default preferences.
		self.archive = []
		self.activateNozzleWipe = preferences.BooleanPreference().getFromValue( 'Activate Nozzle Wipe', False )
		self.archive.append( self.activateNozzleWipe )
		self.filenameInput = preferences.Filename().getFromFilename( import_translator.getGNUTranslatorGcodeFileTypeTuples(), 'Open File to be Nozzle Wiped', '' )
		self.archive.append( self.filenameInput )
		self.locationArrivalX = preferences.FloatPreference().getFromValue( 'Location Arrival X (mm):', - 70.0 )
		self.archive.append( self.locationArrivalX )
		self.locationArrivalY = preferences.FloatPreference().getFromValue( 'Location Arrival Y (mm):', - 50.0 )
		self.archive.append( self.locationArrivalY )
		self.locationArrivalZ = preferences.FloatPreference().getFromValue( 'Location Arrival Z (mm):', 50.0 )
		self.archive.append( self.locationArrivalZ )
		self.locationDepartureX = preferences.FloatPreference().getFromValue( 'Location Departure X (mm):', - 70.0 )
		self.archive.append( self.locationDepartureX )
		self.locationDepartureY = preferences.FloatPreference().getFromValue( 'Location Departure Y (mm):', - 40.0 )
		self.archive.append( self.locationDepartureY )
		self.locationDepartureZ = preferences.FloatPreference().getFromValue( 'Location Departure Z (mm):', 50.0 )
		self.archive.append( self.locationDepartureZ )
		self.locationWipeX = preferences.FloatPreference().getFromValue( 'Location Wipe X (mm):', - 70.0 )
		self.archive.append( self.locationWipeX )
		self.locationWipeY = preferences.FloatPreference().getFromValue( 'Location Wipe Y (mm):', - 70.0 )
		self.archive.append( self.locationWipeY )
		self.locationWipeZ = preferences.FloatPreference().getFromValue( 'Location Wipe Z (mm):', 50.0 )
		self.archive.append( self.locationWipeZ )
		self.nozzleWipePeriod = preferences.IntPreference().getFromValue( 'Nozzle Wipe Period (layers):', 3 )
		self.archive.append( self.nozzleWipePeriod )
		#Create the archive, title of the execute button, title of the dialog & preferences filename.
		self.executeTitle = 'Nozzle Wipe'
		self.filenamePreferences = preferences.getPreferencesFilePath( 'nozzle_wipe.csv' )
		self.filenameHelp = 'skeinforge_tools.nozzle_wipe.html'
		self.saveTitle = 'Save Preferences'
		self.title = 'Nozzle Wipe Preferences'

	def execute( self ):
		"Nozzle wipe button has been clicked."
		filenames = polyfile.getFileOrDirectoryTypesUnmodifiedGcode( self.filenameInput.value, import_translator.getGNUTranslatorFileTypes(), self.filenameInput.wasCancelled )
		for filename in filenames:
			writeOutput( filename )


def main( hashtable = None ):
	"Display the nozzle wipe dialog."
	if len( sys.argv ) > 1:
		writeOutput( ' '.join( sys.argv[ 1 : ] ) )
	else:
		preferences.displayDialog( NozzleWipePreferences() )

if __name__ == "__main__":
	main()
