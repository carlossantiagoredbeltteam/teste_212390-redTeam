"""
Analyze is a script to analyze and comment a gcode file.

To run analyze, install python 2.x on your machine, which is avaliable from http://www.python.org/download/

Then in the folder which analyze is in, type 'python' in a shell to run the python interpreter.  Finally type
'from analyze import *' to import this program.
To get documentation for this program, open a shell in the fill.py directory, then type 'pydoc fill.py'.

An explanation of the gcodes is at:
http://reprap.org/bin/view/Main/Arduino_GCode_Interpreter

A gode example is at:
http://forums.reprap.org/file.php?12,file=565

This example analyzes and comments the gcode file Screw Holder_comb.gcode.  This example is run in a terminal in the folder which contains Screw Holder_comb.gcode and analyze.py.

>>> import analyze
Fillet has been imported.
The gcode files in this directory that are not comment files are the following:
['Screw Holder_comb.gcode']

>>> analyze.comment()
File Screw Holder_comb.gcode is being commented.
..
many lines of commented gcode
..
The commented file is saved as Screw Holder_comb_comment.gcode


>>> analyze.statisticFile()
Statistics are being generated for the file Screw Holder_comb.gcode

On the X axis, the extrusion starts at -30 mm and ends at 30 mm, for a width of 59 mm
On the Y axis, the extrusion starts at -20 mm and ends at 20 mm, for a depth of 39 mm
On the Z axis, the extrusion starts at -4 mm and ends at 11 mm, for a height of 14 mm
The average feedrate is 10 mm/s, (600 mm/min).
The extruder speed is 210
The extruder was extruding 86% of the time.
The extruder was toggled 830 times.
The extrusion diameter is 0.8 mm.
The extrusion width is 0.747 mm.
The following procedures have been performed on the skein:
slice)
fill)
comb)
The layer thickness is 0.747 mm.
The text has 10163 lines and a size of 292.0 KB.
The total build time is 3090 s.
The total distance extruded is 26468 mm.
The total distance traveled is 30896 mm.
The volume extruded is 13 cc.

The statistics file is saved as Screw Holder_comb.txt

"""

from vec3 import Vec3
import cStringIO
import euclidean
import gcodec
import math
import os


__author__ = "Enrique Perez (perez_enrique@yahoo.com)"
__date__ = "$Date: 2008/21/04 $"
__license__ = "GPL 3.0"


def commentFile( filename = '' ):
	"Comment a gcode file.  If no filename is specified, comment the first gcode file in this folder that is not a comment file."
	if filename == '':
		unmodified = getUncommentedGcodeFiles()
		if len( unmodified ) == 0:
			print( "There is no gcode file in this folder that is not a comment file." )
			return
		filename = unmodified[ 0 ]
	print( 'File ' + filename + ' is being commented.' )
	fileText = gcodec.getFileText( filename )
	gcodec.writeFileMessageEnd( '_comment.gcode', filename, getCommentGcode( fileText ), 'The commented file is saved as ' )

def getCommentGcode( gcodeText ):
	"Get gcode text with added comments."
	skein = commentSkein()
	skein.parseGcode( gcodeText )
	return skein.output.getvalue()

def getStatisticGcode( gcodeText ):
	"Get statistics for a gcode text."
	skein = statisticSkein()
	skein.parseGcode( gcodeText )
	return skein.output.getvalue()

def getUncommentedGcodeFiles():
	"Get gcode files which are not generated by this script."
	return gcodec.getFilesWithFileTypeWithoutWords( 'gcode', [ '_comment' ] )

def statisticFile( filename = '' ):
	"Write statistics for a gcode file.  If no filename is specified, write statistics for the first gcode file in this folder that is not a comment or log file."
	if filename == '':
		unmodified = getUncommentedGcodeFiles()
		if len( unmodified ) == 0:
			print( "There is no gcode file in this folder that is not a comment or log file." )
			return
		filename = unmodified[ 0 ]
	print( 'Statistics are being generated for the file ' + filename )
	fileText = gcodec.getFileText( filename )
	gcodec.writeFileMessageEnd( '.txt', filename, getStatisticGcode( fileText ), 'The statistics file is saved as ' )

class commentSkein:
	"A class to comment a gcode skein."
	def __init__( self ):
		self.oldLocation = None
		self.output = cStringIO.StringIO()

	def addComment( self, comment ):
		"Add a gcode comment and a newline to the output."
		self.output.write( "( " + comment + " )\n" )

	def linearMove( self, splitLine ):
		"Comment a linear move."
		location = gcodec.getLocationFromSplitLine( self.oldLocation, splitLine )
		self.addComment( "Linear move to " + str( location ) + "." );
		self.oldLocation = location

	def parseGcode( self, gcodeText ):
		"Parse gcode text and store the commented gcode."
		lines = gcodec.getTextLines( gcodeText )
		for line in lines:
			self.parseLine( line )
		print( self.output.getvalue() )

	def parseLine( self, line ):
		"Parse a gcode line and add it to the commented gcode."
		splitLine = line.split( ' ' )
		if len( splitLine ) < 1:
			return
		firstWord = splitLine[ 0 ]
		if firstWord == 'G1':
			self.linearMove( splitLine )
		elif firstWord == 'G2':
			self.setHelicalMoveEndpoint( splitLine )
			self.addComment( "Helical clockwise move to " + str( self.oldLocation ) + "." )
		elif firstWord == 'G3':
			self.setHelicalMoveEndpoint( splitLine )
			self.addComment( "Helical counterclockwise move to " + str( self.oldLocation ) + "." )
		elif firstWord == 'G21':
			self.addComment( "Set units to mm." )
		elif firstWord == 'G28':
			self.addComment( "Start at home." )
		elif firstWord == 'G90':
			self.addComment( "Set positioning to absolute." )
		elif firstWord == 'M100':
			self.addComment( "Set extruder speed to " + str( gcodec.getDoubleAfterFirstLetter( splitLine[ 1 ] ) ) + "." )
		elif firstWord == 'M101':
			self.addComment( "Turn extruder on." );
		elif firstWord == 'M103':
			self.addComment( "Turn extruder off." )
		elif firstWord == 'M104':
			self.addComment( "Set temperature to " + str( gcodec.getDoubleAfterFirstLetter( splitLine[ 1 ] ) ) + " C." )
		elif firstWord == 'M105':
			self.addComment( "Custom code for temperature reading." )
		elif firstWord == 'M106':
			self.addComment( "Turn fan on." )
		elif firstWord == 'M107':
			self.addComment( "Turn fan off." )
		elif firstWord == '(<extrusionDiameter>':
			self.addComment( "Set extrusion diameter to " + str( gcodec.getDoubleAfterFirstLetter( splitLine[ 1 ] ) ) + " mm." )
		elif firstWord == '(<extrusionWidth>':
			self.addComment( "Set extrusion width to " + str( gcodec.getDoubleAfterFirstLetter( splitLine[ 1 ] ) ) + " mm." )
		elif firstWord == '(<extrusionHeight>':
			self.addComment( "Set layer thickness to " + str( gcodec.getDoubleAfterFirstLetter( splitLine[ 1 ] ) ) + " mm." )
		elif firstWord == '(<procedureDone>':
			self.addComment( "The " + splitLine[ 1 ][ 1 : ] + " procedure has been performed." )
		elif firstWord == '(<extrusionStart>':
			self.addComment( "Initialization is finished, extrusion is starting." )
		elif firstWord == '(<layerStart>':
			self.addComment( "New layer is starting." )
		elif firstWord == '(<loop>':
			self.addComment( "Loop is starting." )
		self.output.write( line + "\n" )

	def setHelicalMoveEndpoint( self, splitLine ):
		"Get the endpoint of a helical move."
		if self.oldLocation == None:
			print( "A helical move must not be the first move of a gcode file." )
			return
		location = gcodec.getLocationFromSplitLine( self.oldLocation, splitLine )
		location.add( self.oldLocation )
		self.oldLocation = location


class statisticSkein( commentSkein ):
	"A class to get statistics for a gcode skein."
	def addLine( self, line ):
		"Add a line of text and a newline to the output."
		self.output.write( line + "\n" )

	def addToPath( self, location ):
		"Add a point to travel and maybe extrusion."
		if self.oldLocation != None:
			travel = location.distance( self.oldLocation )
			if self.feedrateMinute > 0.0:
				self.totalBuildTime += 60.0 * travel / self.feedrateMinute
			self.totalDistanceTraveled += travel
			if self.extruderActive:
				self.totalDistanceExtruded += travel
				self.cornerHigh = euclidean.getPointMaximum( self.cornerHigh, location )
				self.cornerLow = euclidean.getPointMinimum( self.cornerLow, location )
		self.oldLocation = location

	def extruderSet( self, active ):
		"Maybe increment the number of times the extruder was toggled."
		if self.extruderActive != active:
			self.extruderToggled += 1
		self.extruderActive = active

	def getLocationSetFeedrateToSplitLine( self, splitLine ):
		location = gcodec.getLocationFromSplitLine( self.oldLocation, splitLine )
		indexOfF = gcodec.indexOfStartingWithSecond( "F", splitLine )
		if indexOfF > 0:
			self.feedrateMinute = gcodec.getDoubleAfterFirstLetter( splitLine[ indexOfF ] )
		return location

	def helicalMove( self, isCounterclockwise, splitLine ):
		"Get statistics for a helical move."
		if self.oldLocation == None:
			return
		location = self.getLocationSetFeedrateToSplitLine( splitLine )
		location.add( self.oldLocation )
		center = Vec3().getFromVec3( self.oldLocation )
		indexOfR = gcodec.indexOfStartingWithSecond( "R", splitLine )
		if indexOfR > 0:
			radius = gcodec.getDoubleAfterFirstLetter( splitLine[ indexOfR ] )
			halfLocationMinusOld = location.minus( self.oldLocation )
			halfLocationMinusOld.scale( 0.5 )
			halfLocationMinusOldLength = halfLocationMinusOld.length()
			centerMidpointDistance = math.sqrt( radius * radius - halfLocationMinusOldLength * halfLocationMinusOldLength )
			centerMinusMidpoint = euclidean.getRotatedWiddershinsQuarterAroundZAxis( halfLocationMinusOld )
			centerMinusMidpoint.normalize()
			centerMinusMidpoint.scale( centerMidpointDistance )
			if isCounterclockwise:
				center.setToVec3( halfLocationMinusOld.plus( centerMinusMidpoint ) )
			else:
				center.setToVec3( halfLocationMinusOld.minus( centerMinusMidpoint ) )
		else:
			center.x = gcodec.getDoubleForLetter( "I", splitLine )
			center.y = gcodec.getDoubleForLetter( "J", splitLine )
		curveSection = 0.5
		center.add( self.oldLocation )
		afterCenterSegment = location.minus( center )
		beforeCenterSegment = self.oldLocation.minus( center )
		afterCenterDifferenceAngle = euclidean.getAngleAroundZAxisDifference( afterCenterSegment, beforeCenterSegment )
		absoluteDifferenceAngle = abs( afterCenterDifferenceAngle )
		steps = int( round( 0.5 + max( absoluteDifferenceAngle * 2.4, absoluteDifferenceAngle * beforeCenterSegment.length() / curveSection ) ) )
		stepPlaneAngle = euclidean.getPolar( afterCenterDifferenceAngle / steps, 1.0 )
		zIncrement = ( afterCenterSegment.z - beforeCenterSegment.z ) / float( steps )
		for step in range( 1, steps ):
			beforeCenterSegment = euclidean.getRoundZAxisByPlaneAngle( stepPlaneAngle, beforeCenterSegment )
			beforeCenterSegment.z += zIncrement
			arcPoint = center.plus( beforeCenterSegment )
			self.addToPath( arcPoint )
		self.addToPath( location )

	def linearMove( self, splitLine ):
		"Get statistics for a linear move."
		location = self.getLocationSetFeedrateToSplitLine( splitLine )
		self.addToPath( location )

	def parseGcode( self, gcodeText ):
		"Parse gcode text and store the commented gcode."
		self.characters = 0
		self.cornerHigh = Vec3( - 999999999.0, - 999999999.0, - 999999999.0 )
		self.cornerLow = Vec3( 999999999.0, 999999999.0, 999999999.0 )
		self.extruderActive = False
		self.extruderSpeed = 0.0
		self.extruderToggled = 0
		self.extrusionDiameter = 0.5
		self.extrusionWidth = 0.4
		self.feedrateMinute = 600.0
		self.extrusionHeight = 0.4
		self.numberOfLines = 0
		self.procedures = []
		self.totalBuildTime = 0.0
		self.totalDistanceExtruded = 0.0
		self.totalDistanceTraveled = 0.0
		lines = gcodec.getTextLines( gcodeText )
		for line in lines:
			self.parseLine( line )
		averageFeedrate = self.totalDistanceTraveled / self.totalBuildTime
		self.characters += self.numberOfLines
		kilobytes = round( self.characters / 1024.0 )
		halfExtrusionWidth = 0.5 * self.extrusionWidth
		halfExtrusionCorner = Vec3( halfExtrusionWidth, halfExtrusionWidth, halfExtrusionWidth )
		self.cornerHigh.add( halfExtrusionCorner )
		self.cornerLow.subtract( halfExtrusionCorner )
		extent = self.cornerHigh.minus( self.cornerLow )
		roundedHigh = euclidean.getRoundedPoint( self.cornerHigh )
		roundedLow = euclidean.getRoundedPoint( self.cornerLow )
		roundedExtent = euclidean.getRoundedPoint( extent )
		axisString =  " axis, the extrusion starts at "
		volumeExtruded = 0.0009 * self.extrusionWidth * self.extrusionHeight * self.totalDistanceExtruded # the 9 comes from a typical fill density of 0.9
		self.addLine( "On the X" + axisString + str( int ( roundedLow.x ) ) + " mm and ends at " + str( int ( roundedHigh.x ) ) + " mm, for a width of " + str( int ( extent.x ) ) + " mm" )
		self.addLine( "On the Y" + axisString + str( int ( roundedLow.y ) ) + " mm and ends at " + str( int ( roundedHigh.y ) ) + " mm, for a depth of " + str( int ( extent.y ) ) + " mm" )
		self.addLine( "On the Z" + axisString + str( int ( roundedLow.z ) ) + " mm and ends at " + str( int ( roundedHigh.z ) ) + " mm, for a height of " + str( int ( extent.z ) ) + " mm" )
		self.addLine( "The average feedrate is "  + str( int( round( averageFeedrate ) ) )  + " mm/s, (" + str( int( round( 60.0 * averageFeedrate ) ) ) + " mm/min)." )
		self.addLine( "The extruder speed is " + str( int( round( self.extruderSpeed ) ) ) )
		self.addLine( "The extruder was extruding "  + str( int( round( 100.0 * self.totalDistanceExtruded / self.totalDistanceTraveled ) ) ) + "% of the time." )
		self.addLine( "The extruder was toggled " + str( self.extruderToggled ) + " times." )
		self.addLine( "The extrusion diameter is "  + str( self.extrusionDiameter ) + " mm." )
		self.addLine( "The extrusion width is "  + str( self.extrusionWidth ) + " mm." )
		self.addLine( "The following procedures have been performed on the skein:" )
		for procedure in self.procedures:
			self.addLine( procedure )
		self.addLine( "The layer thickness is "  + str( self.extrusionHeight ) + " mm." )
		self.addLine( "The text has " + str( self.numberOfLines ) + " lines and a size of " + str( kilobytes ) + " KB." )
		self.addLine( "The total build time is " + str( int( round( self.totalBuildTime ) ) ) + " s." )
		self.addLine( "The total distance extruded is " + str( int( round( self.totalDistanceExtruded ) ) ) + " mm." )
		self.addLine( "The total distance traveled is " + str( int( round( self.totalDistanceTraveled ) ) ) + " mm." )
		self.addLine( "The volume extruded is "  + str( int( round( volumeExtruded ) ) ) + " cc." )
		print( '' )
		print( self.output.getvalue() )
		print( '' )

	def parseLine( self, line ):
		"Parse a gcode line and add it to the commented gcode."
		self.characters += len( line )
		self.numberOfLines += 1
		splitLine = line.split( ' ' )
		if len( splitLine ) < 1:
			return
		firstWord = splitLine[ 0 ]
		if firstWord == 'G1':
			self.linearMove( splitLine )
		elif firstWord == 'G2':
			self.helicalMove( False, splitLine )
		elif firstWord == 'G3':
			self.helicalMove( True, splitLine )
		elif firstWord == 'M100':
			self.extruderSpeed = gcodec.getDoubleAfterFirstLetter( splitLine[ 1 ] )
		elif firstWord == 'M101':
			self.extruderSet( True )
		elif firstWord == 'M103':
			self.extruderSet( False )
		elif firstWord == '(<extrusionDiameter>':
			self.extrusionDiameter = gcodec.getDoubleAfterFirstLetter( splitLine[ 1 ] )
		elif firstWord == '(<extrusionWidth>':
			self.extrusionWidth = gcodec.getDoubleAfterFirstLetter( splitLine[ 1 ] )
		elif firstWord == '(<extrusionHeight>':
			self.extrusionHeight = gcodec.getDoubleAfterFirstLetter( splitLine[ 1 ] )
		elif firstWord == '(<procedureDone>':
			self.procedures.append( splitLine[ 1 ][ 1 : ] )


print( 'Analyze has been imported.' )
print( 'The gcode files in this directory that are not comment files are the following:' )
print( getUncommentedGcodeFiles() )