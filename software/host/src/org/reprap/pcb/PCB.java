package org.reprap.pcb;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.File;
import java.util.Date;
import java.text.SimpleDateFormat;
import org.reprap.Extruder;
import org.reprap.Attributes;
import org.reprap.Preferences;
import org.reprap.geometry.polygons.*;
import org.reprap.utilities.RrGraphics;
import org.reprap.comms.GCodeReaderAndWriter;

//import java.io.IOException;

public class PCB {
	
	GerberGCode gerberGcode; 
	String[] splitline;
	boolean debug = false;
	RrRectangle bigBox;
	BufferedReader in;
	String line;
	String formatX = "23", formatY="23";

	double scale = 1;

	double penWidth = 0.7;
	double zFeedRate = 50;
	double zDown = 0;
	static final double centreWidth = 0.9;
	static final double offsetX=10;
	static final double offsetY=10;
	File inputTracksAndPads;
	File inputDrill;
	File outputGCodes;
	Extruder pcbPen;
	RrPolygonList penPaths;
	GCodeReaderAndWriter gcode;

	/**
	 * @param args
	 */
	public void pcb(File itp, File id, File og, Extruder pp) 
	{
		inputTracksAndPads = itp;
		inputDrill = id;
		outputGCodes = og;
		pcbPen = pp;
		penWidth = pcbPen.getExtrusionSize();
		System.out.println("Gerber RS274X to GCoder Converter for RepRap\n");


		System.out.println("Input: " + inputTracksAndPads.getName());
		System.out.println("Output: " + outputGCodes.getName()+"\n");
		System.out.println("Pen Width: " + penWidth + " mm");
		System.out.println("Offset X: " + offsetX + " mm");
		System.out.println("Offset Y: " + offsetY + " mm");

		createBitmap();

		penPaths = gerberGcode.getPolygons();
		
		penPaths = penPaths.nearEnds(new Rr2Point(0, 0), true, 1.5*penWidth);
		
		try 
		{
			if(Preferences.loadGlobalBool("DisplaySimulation"))
			{
				RrGraphics simulationPlot2 = new RrGraphics("PCB plotlines");
//				if(currentPolygon != null)
//					thePattern.add(new RrPolygon(currentPolygon));
				simulationPlot2.init(penPaths.getBox(), false, 0);
				simulationPlot2.add(penPaths);
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		writeGCodes();
			
		System.out.println("GCode file generated succesfully !");
	}
	
	private void raisePen()
	{
		try {
			gcode.queue("G1 F" + zFeedRate + "; Z feedrate");
			gcode.queue("G1 Z" + pcbPen.getLift() + "; Z clearance height");
			gcode.queue("G1 F" + pcbPen.getSlowXYFeedrate() + "; XY feedrate");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private void lowerPen()
	{
		try {
			gcode.queue("G1 F" + zFeedRate + "; Z feedrate");
			gcode.queue("G1 Z" + zDown + "; Z drawing height");
			gcode.queue("G1 F" + pcbPen.getSlowXYFeedrate() + "; XY feedrate");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private void PCBHeader()
	{
		gcode.startRun();
		try 
		{
			gcode.queue("; PCB GCode generated by RepRap Java Host Software");
			Date myDate = new Date();
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd:HH-mm-ss");
			String myDateString = sdf.format(myDate);
			gcode.queue("; Created: " + myDateString);
			gcode.queue("; Gerber tracks and pads file: " + inputTracksAndPads.getName());
			gcode.queue("; Drill file: " + inputDrill.getName());
			gcode.queue(";#!RECTANGLE: " + bigBox);
			gcode.queue(";#!LAYER: 1/1");
			gcode.queue("G21 ;metric");
			gcode.queue("G90 ;absolute positioning");
			gcode.queue("M140 S0.0 ;set bed temperature and return");
			gcode.queue("T" + pcbPen.getPhysicalExtruderNumber() + "; select new extruder");
			//gcode.queue("M113; set extruder to use pot for PWM");
			gcode.queue("G28; go home");
			gcode.queue("G92 E0 ;zero the extruded length");
			raisePen();
		} catch (Exception e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private void PCBFooter()
	{
		try 
		{
			gcode.queue("M0 ; stop RepRap");
		} catch (Exception e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private void polygonPlot(RrPolygon p)
	{
		if(p.size() <= 0)
			return;
		try {
		gcode.queue("G1 X" + p.point(0).x() + " Y" + p.point(0).y() + "; move to polygon start");
		lowerPen();
		for(int i = 1; i < p.size(); i++)
			gcode.queue("G1 X" + p.point(i).x() + " Y" + p.point(i).y() + "; draw line");
		gcode.queue("G1 X" + p.point(0).x() + " Y" + p.point(0).y() + "; draw back to polygon start");
		} catch (Exception e) {
			e.printStackTrace();
			return;
		}
		raisePen();
	}
	
	private void writeGCodes()
	{
		try {
			gcode = new GCodeReaderAndWriter(new PrintStream(outputGCodes));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			return;
		}
		PCBHeader();
		for(int i = 0; i < penPaths.size(); i++)
			polygonPlot(penPaths.polygon(i));
		PCBFooter();
	}
	
	private void createBitmap()
	{
		gerberGcode = new GerberGCode(pcbPen, null, true); //, drawingHeight, freemoveHeight, XYFeedrate, ZFeedrate);
		
		bigBox = new RrRectangle();

		// processing Gerber file
		try {
			in = new BufferedReader(new FileReader(inputTracksAndPads));

			while((line = in.readLine()) != null)
			{
				RrRectangle r = processLine(line, false);
				if(r != null)
					bigBox = RrRectangle.union(bigBox, r);
			}
			if(debug)
				System.out.println("Surrounding reactangle: " + bigBox);
			in.close();
			
			in = new BufferedReader(new FileReader(inputTracksAndPads));
			
			BooleanGrid pattern = new BooleanGrid(RrCSG.nothing(), bigBox, new Attributes(null, null, null, pcbPen.getAppearance()));
			
			gerberGcode = new GerberGCode(pcbPen, pattern, true);

			while((line = in.readLine()) != null)
			{
				processLine(line, false);
			}

			if(inputDrill != null)
			{
				in = new BufferedReader(new FileReader(inputDrill));
				gerberGcode = new GerberGCode(pcbPen, pattern, false);
				gerberGcode.addCircleAperture(-1, centreWidth); // Just mark drill centres with a disc
				while((line = in.readLine()) != null)
				{
					processLine(line, true);
				}
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private RrRectangle processLine(String line, boolean drill)
	{
		if(debug) System.out.println(line);
		
		boolean drillDef = false;
		
		RrRectangle result = null;
		if(drill)
		{
			formatX = "24";
			formatY = "24";			
		}

		if(line.startsWith("%FSLA"))
		{

			formatX = line.substring(6, 8);
			formatY = line.substring(9, 11);
			if(debug) System.out.println("Format X: " + formatX + " Format Y: " + formatY);
		}
		else
			if(line.startsWith("%ADD"))
			{
				String apertureNum, apertureType, apertureSize;


				line = line.substring(4, line.length()-2);
				apertureNum = line.substring(0, 2); 

				line = line.substring(2);
				splitline = line.split(",");
				apertureType = splitline[0];
				apertureSize = splitline[1]; 

				if(debug) 
				{
					System.out.println("\n\nAparture: " + apertureNum);
					System.out.println("Type: " + apertureType);
				}

				if(apertureType.equals("C"))
				{
					double s = scale*Double.parseDouble(apertureSize);
					gerberGcode.addCircleAperture(Integer.parseInt(apertureNum), s);
					if(debug) 
						System.out.println("Size: " + s + " mm");
				}
				else
					if(apertureType.equals("R"))
					{

						String rectSides[] = apertureSize.split("X");
						double x = scale*Double.parseDouble(rectSides[0]);
						double y = scale*Double.parseDouble(rectSides[1]);

						gerberGcode.addRectangleAperture(Integer.parseInt(apertureNum), x, y);
						if(debug) 
							System.out.println("Size: " + x + "x" + y + "mm x mm");
					}
					else
						if(apertureType.equals("OC8"))
						{
							gerberGcode.addCircleAperture(Integer.parseInt(apertureNum), scale*Double.parseDouble(apertureSize));							
						}
						else
						{
							System.out.println(" [-] aparture type: " + apertureType + " not supported [" + line+"]\n");
							//System.exit(-1);
						}

			} else
				if(line.startsWith("T") && drill && line.length() > 3)
				{
					if(line.charAt(3) == 'C')
					{
						String apertureNum, apertureSize;


						line = line.substring(1, line.length()); 

						splitline = line.split("C");
						apertureNum = splitline[0];
						apertureSize = splitline[1]; 

						if(debug) 
							System.out.println("\n\nDrill: " + apertureNum);

						drillDef = true;

						double s = scale*Double.parseDouble(apertureSize);
						gerberGcode.addCircleAperture(Integer.parseInt(apertureNum), s);
						if(debug) 
							System.out.println("Size: " + s + " mm");
					}
				}
				else
					if(line.startsWith("G90"))
					{
						gerberGcode.enableAbsolute();
						if(debug)
							System.out.println("Absolute coordinates");
					}
					else
						if(line.startsWith("G91"))
						{
							gerberGcode.enableRelative();
							if(debug)
								System.out.println("Relative coordinates");
						}
						else
							if(line.startsWith("G70") || (drill && line.startsWith("M72")))
							{
								scale = 25.4;
								if(debug)
									System.out.println("Inches");
							}
							else
								if(line.startsWith("G71")|| (drill && line.startsWith("M71")))
								{
									scale = 1;
									if(debug)
										System.out.println("Metric");
								}
								else
									if(line.startsWith("G54"))
									{
										if(drill)
										{
											gerberGcode.selectAperture(-1);
											if(debug)
												System.out.println("Drill centre selected.");
										} else
										{
											int aperture;

											aperture = Integer.valueOf(line.substring(4, line.length()-1).trim());
											gerberGcode.selectAperture(aperture);
											if(debug)
												System.out.println("Apature: " + aperture + " selected.");
										}

									}
									else
										if(line.startsWith("X"))
										{
											double x, y;
											int d;
											if(drill)
											{
												d = 3;
												line = line.substring(1);
												splitline = line.split("Y");
												while(splitline[0].length() < 6)
													splitline[0] = "0" + splitline[0];
												while(splitline[1].length() < 6)
													splitline[1] = "0" + splitline[1];
											} else
											{
												splitline[0] = line.substring(1, line.indexOf("Y"));
												splitline[1] = line.substring(line.indexOf("Y")+1, line.indexOf("D"));
												d = Integer.valueOf(line.substring(line.indexOf("D")+1, line.indexOf("D")+3));
											}
							
											int divFactorX = (int)Math.pow(10.0,Integer.parseInt(formatX.substring(1)));
											int divFactorY = (int)Math.pow(10.0,Integer.parseInt(formatY.substring(1)));

											x = scale*Double.valueOf(splitline[0])/divFactorX;
											y = scale*Double.valueOf(splitline[1])/divFactorY;

											x += offsetX;
											y += offsetY;

											if(debug)
												System.out.println(" X: "+x+" Y:"+y+" D:"+d);

											if(d==1)
											{
												result = gerberGcode.drawLine(new Rr2Point(x, y));
											}
											else
												if(d==2)
												{
													gerberGcode.goTo(new Rr2Point(x, y));
												}	
												else
													if(d==3)
													{
														result = gerberGcode.exposePoint(new Rr2Point(x, y));
													}
										}
										else
											if(line.startsWith("D") || (line.startsWith("T") && drill && !drillDef))
											{
												if(drill)
												{
													gerberGcode.selectAperture(-1);
													if(debug)
														System.out.println("Drill centre selected.");
												} else
												{
													int aperture;

													aperture = Integer.valueOf(line.substring(1, 3));
													gerberGcode.selectAperture(aperture);

													if(debug)
														System.out.print("Apature: " + aperture + " selected.");
												}
											}
		return result;
	}
}
