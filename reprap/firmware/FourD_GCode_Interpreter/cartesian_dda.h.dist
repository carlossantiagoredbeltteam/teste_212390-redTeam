/*
 * This class controls the movement of the RepRap machine.
 * It implements a DDA in four dimensions, so the length of extruded 
 * filament is treated as a variable, just like X, Y, and Z.
 *
 * Adrian Bowyer 9 May 2009
 */

#ifndef CARTESIAN_DDA_H
#define CARTESIAN_DDA_H

#define round(x) ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))

// Structs to hold points in 5D space.

// Real-world units
struct FloatPoint
{
	float x;   // Coordinate axes
	float y;
	float z;
        float e;   // Extrude length
        float f;   // Feedrate
};

inline FloatPoint operator+(const FloatPoint& a, const FloatPoint& b)
{
  FloatPoint result;
  result.x = a.x + b.x;
  result.y = a.y + b.y;
  result.z = a.z + b.z;
  result.e = a.e + b.e;
  result.f = a.f + b.f;
  return result;
}  

inline FloatPoint operator-(const FloatPoint& a, const FloatPoint& b)
{
  FloatPoint result;
  result.x = a.x - b.x;
  result.y = a.y - b.y;
  result.z = a.z - b.z;
  result.e = a.e - b.e;
  result.f = a.f - b.f;
  return result;
} 


// NB - the next gives neither the scalar nor the vector product

inline FloatPoint operator*(const FloatPoint& a, const FloatPoint& b)
{
  FloatPoint result;
  result.x = a.x * b.x;
  result.y = a.y * b.y;
  result.z = a.z * b.z;
  result.e = a.e * b.e;
  result.f = a.f * b.f;
  return result;
} 

// Can't use abs for this as it's defined somewhere in a #define

inline FloatPoint absv(const FloatPoint& a)
{
  FloatPoint result;
  result.x = abs(a.x);
  result.y = abs(a.y);
  result.z = abs(a.z);
  result.e = abs(a.e);
  result.f = abs(a.f);
  return result;
} 


// Integer numbers of steps
struct LongPoint
{
	long x;   // Coordinates
	long y;
	long z;
        long e;   // Extrusion
        long t;   // Time delay
};

inline LongPoint operator+(const LongPoint& a, const LongPoint& b)
{
  LongPoint result;
  result.x = a.x + b.x;
  result.y = a.y + b.y;
  result.z = a.z + b.z;
  result.e = a.e + b.e;
  result.t = a.t + b.t;
  return result;
}  

inline LongPoint operator-(const LongPoint& a, const LongPoint& b)
{
  LongPoint result;
  result.x = a.x - b.x;
  result.y = a.y - b.y;
  result.z = a.z - b.z;
  result.e = a.e - b.e;
  result.t = a.t - b.t;
  return result;
} 

// NB - the next gives neither the scalar nor the vector product

inline LongPoint operator*(const LongPoint& a, const LongPoint& b)
{
  LongPoint result;
  result.x = a.x * b.x;
  result.y = a.y * b.y;
  result.z = a.z * b.z;
  result.e = a.e * b.e;
  result.t = a.t * b.t;
  return result;
} 

inline LongPoint absv(const LongPoint& a)
{
  LongPoint result;
  result.x = abs(a.x);
  result.y = abs(a.y);
  result.z = abs(a.z);
  result.e = abs(a.e);
  result.t = abs(a.t);
  return result;
} 

// NB - watch the f -> t; you need to do something about it

inline LongPoint roundv(const FloatPoint& a)
{
  LongPoint result;
  result.x = round(a.x);
  result.y = round(a.y);
  result.z = round(a.z);
  result.e = round(a.e);
  result.t = round(a.f);
  return result;
} 


// Main class for moving the RepRap machine about

class cartesian_dda
{
private:

  extruder* ext;               // The extruder I'm currently using - keep this up to date...

  FloatPoint units;            // Factors for converting either mm or inches to steps

  FloatPoint current_position; // Where the machine is
  FloatPoint target_position;  // Where it's going
  FloatPoint delta_position;   // The difference between the two
  float distance;              // How long the path is
  
  LongPoint current_steps;     // Similar information as above in steps rather than units
  LongPoint target_steps;
  LongPoint delta_steps;
  LongPoint dda_counter;       // DDA error-accumulation variables
  
  byte x_direction;            // Am I going in the + or - direction?
  byte y_direction;
  byte z_direction;
  byte e_direction;
  byte t_direction;

  bool x_can_step;             // Am I not at an endstop?  Have I not reached the target? etc.
  bool y_can_step;
  bool z_can_step;
  bool e_can_step;
  bool t_can_step;

// Variables for acceleration calculations

  long total_steps;            // The number of steps to take along the longest movement axis

// Internal functions that need not concern the user

  // Take a single step

  void do_x_step();               
  void do_y_step();
  void do_z_step();
  void do_e_step();
  void do_t_step(); 
  
  void dda_move();  // Run the DDA
  
  // Can this axis step?
  
  bool can_step(byte min_pin, byte max_pin, long current, long target, byte dir);
  
  // Read a limit switch
  
  bool read_switch(byte pin);
  
  // Set where I'm going
  
  bool set_target(const FloatPoint& p);
  
  // Work out the number of microseconds between steps
  
  long calculate_feedrate_delay(float feedrate);
  
  // Switch the steppers on and off
  
  void enable_steppers();
  void disable_steppers();
  
  // Custom short delay function (microseconds)
  
  void delayMicrosecondsInterruptible(unsigned int us);
  
public:

  cartesian_dda();
  
  // Move somewhere at a given speed
  
  void move(const FloatPoint& p);
  
  // True for mm; false for inches
  
  void set_units(bool using_mm);
  
  // Override where I think I am
  
  void set_position(const FloatPoint& p);
  
  // Report where I am
  
  FloatPoint where_i_am();
  
  // Record the selection of a new extruder
  
  void set_extruder(extruder* ex);
};

// Short functions inline to save memory; particularly useful in the Arduino

inline void cartesian_dda::set_position(const FloatPoint& p)
{
	current_position = p;
}

inline void cartesian_dda::move(const FloatPoint& p)
{
  if(!set_target(p))
  {
    set_position(p);
    return;
  }
  dda_move();
}

inline void cartesian_dda::set_extruder(extruder* ex)
{
  ext = ex;
}

inline FloatPoint cartesian_dda::where_i_am()
{
  return current_position;
}

inline void cartesian_dda::do_x_step()
{
	digitalWrite(X_STEP_PIN, HIGH);
	delayMicroseconds(5);
	digitalWrite(X_STEP_PIN, LOW);
}

inline void cartesian_dda::do_y_step()
{
	digitalWrite(Y_STEP_PIN, HIGH);
	delayMicroseconds(5);
	digitalWrite(Y_STEP_PIN, LOW);
}

inline void cartesian_dda::do_z_step()
{
	digitalWrite(Z_STEP_PIN, HIGH);
	delayMicroseconds(5);
	digitalWrite(Z_STEP_PIN, LOW);
}

inline void cartesian_dda::do_e_step()
{
        ext->step();
}

inline void cartesian_dda::do_t_step()
{

}

inline long to_steps(float steps_per_unit, float units)
{
	return round(steps_per_unit * units);
}

inline LongPoint to_steps(const FloatPoint& units, const FloatPoint& position)
{
        return roundv(units*position);
}
#endif
