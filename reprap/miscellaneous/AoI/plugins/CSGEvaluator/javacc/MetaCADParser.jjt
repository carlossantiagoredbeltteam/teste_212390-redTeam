/* Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 
options {
  TRACK_TOKENS=true;
}


PARSER_BEGIN(MetaCADParser)

package org.reprap.artofillusion.parser;

import org.reprap.artofillusion.ParsedTree;
import org.reprap.artofillusion.TreeObject;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

import artofillusion.object.ObjectInfo;


/** Simple brace matcher. */
public class MetaCADParser {
  
  /** Main entry point. */
  
  public static TreeObject parseTree(String txt) throws ParseException {
    MetaCADParser parser = new MetaCADParser(new StringReader(txt));
    return parser.Object();
  }
  
  public static String dumpTokens(SimpleNode node)
  {
	Token first = node.jjtGetFirstToken();
	Token last = node.jjtGetLastToken();
	
	String s=first.image;
	while (first != last)
	{
		first = first.next;
		s = s  + first.image;
	}
	return s;
  }

}

PARSER_END(MetaCADParser)

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < COMMA: "," >
| < DOT: "." >
}

TOKEN :
{
  <REAL_LITERAL: (["0"-"9"])+ ("." (["0"-"9"])* (<EXPONENT>)?)? >
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
}

TOKEN : /* BINARY OPS */
{
	< PLUS: "+" >
|	< MINUS: "-" >
|	< OTHERBINOP: ["*","/"] >
}

TOKEN : /* IDENTIFIERS */
{

<IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>)*>
| < #LETTER: 
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a"/*,
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"*/
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039"/*,
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"*/
      ]
  >
}

/** Root production. 
ArrayList<ObjectInfo> ObjectTree() :
{
	ArrayList<ObjectInfo> elements = new ArrayList<ObjectInfo>();;	
}
{
 <LBRACE> [Object() (<COMMA> Object())* ] <RBRACE>
{
		return new ArrayList<ObjectInfo>();
}
}
*/

TreeObject Object() :
{
	ParsedTree tree;
	List<TreeObject> children=null;
}
{
	tree = FunctionCallList() (<LBRACE>children=ObjectList()<RBRACE>)? ";"
{
	if (children != null)
	{
		ParsedTree bottom = tree;
		while (bottom.children.size() != 0) { bottom = (ParsedTree)bottom.children.get(0); };
		bottom.children = children;
	}
	
	return tree;
}
}

List<TreeObject> ObjectList() :
{	
	List<TreeObject> list = new ArrayList<TreeObject>();
	TreeObject current;
}
{
	(current = Object() { list.add(current); })*
	{
		return list;
	}
}


ParsedTree FunctionCallList() :
{
	ParsedTree current = new ParsedTree();
	List<ParsedTree> trees =  new ArrayList<ParsedTree>();
}
{
	(current = FunctionCall() {trees.add(current);})+ 
	{
		for (int i = trees.size()-2; i >= 0; i--)
		{
			trees.get(i+1).children.add(trees.get(i));	
		}	
		return current;
	}
}

ParsedTree FunctionCall() :
{
	ParsedTree tree = new ParsedTree();
	Token name;
	List <String> params = new ArrayList<String>(); 
}
{
	name = <IDENTIFIER><LPAREN>(params = ParameterList())?<RPAREN>
	{
		tree.name = name.image;
		tree.parameters =  params;
		return tree;
	}
		
}

List<String> ParameterList() :
{
	List<String> expressions = new ArrayList<String>();
	String current;
}
{
	current = Expression(){expressions.add(current);}(<COMMA>current=Expression(){expressions.add(current);})*
	{
		return expressions;
	}
}

void JEPFunctionCall() :
{
}
{
	<IDENTIFIER>(<LPAREN>(ParameterList())?<RPAREN>)?
}

/** Brace counting production. */
void UnaryExpression() :
{
}
{
	<REAL_LITERAL>	|  JEPFunctionCall()  | <LPAREN>Expression()<RPAREN> | <MINUS> UnaryExpression()
}

/** Brace counting production. */
String Expression() :
{
}
{
	UnaryExpression()((<PLUS>|<MINUS>|<OTHERBINOP>)UnaryExpression())*
	{
		return dumpTokens(jjtThis);
	}
}
