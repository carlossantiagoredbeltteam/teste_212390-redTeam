options {
  TRACK_TOKENS=true;
  LOOKAHEAD=3;
  FORCE_LA_CHECK=true;
}


PARSER_BEGIN(MetaCADParser)

package org.reprap.artofillusion.parser;


import org.reprap.artofillusion.ObjFactory;
import org.reprap.artofillusion.ParsedTree;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;


/** Simple brace matcher. */
public class MetaCADParser {
  protected static MetaCADParser theParser = null;
  protected static MetaCADParser getSingleton(String txt)
  {
        if (theParser== null)
        {
        	theParser=new MetaCADParser(new StringReader(txt));
        }
        else
        {
        	theParser.ReInit(new StringReader(txt));
        }
        return theParser;
  }

  public static ParsedTree parseTree(String txt) throws ParseException {
    try
	{
		MetaCADParser parser = getSingleton(txt);
		return parser.Object();
	}
	catch (Throwable ex)
	{
		ParseException newEx = new ParseException(ex.getMessage() + " in:\n" + txt);
		newEx.initCause(ex);
		throw newEx;
	}
  }
  
  public static String dumpTokens(SimpleNode node)
  {
	Token first = node.jjtGetFirstToken();
	Token last = node.jjtGetLastToken();
	
	String s=first.image;
	while (first != last)
	{
		first = first.next;
		s = s  + first.image;
	}
	return s;
  }

}

PARSER_END(MetaCADParser)

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < COMMA: "," >
| < DOT: "." >
}

TOKEN :
{
  <REAL_LITERAL: (["0"-"9"])+ ("." (["0"-"9"])* (<EXPONENT>)?)? >
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
}

TOKEN : /* BINARY OPS */
{
	< PLUS: "+" >
|	< MINUS: "-" >
|   < DIVIDE: "/" >
|	< OTHERBINOP: ["*","^","=", ">","<"] >
}

TOKEN : /* IDENTIFIERS */
{

<IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>)*>
| < #LETTER: 
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a"/*,
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"*/
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039"/*,
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"*/
      ]
  >
}

ParsedTree Object() :
{
	ParsedTree tree;
	List<ParsedTree> children=null;
}
{
	tree = FunctionCallList() (<LBRACE>children=ObjectList()<RBRACE>)?
{
	if (children != null)
	{
		ParsedTree bottom = tree;
		while (bottom.children.size() != 0) { bottom = bottom.children.get(0); };
		bottom.children = children;
	}
	
	return tree;
}
}

List<ParsedTree> ObjectList() :
{	
	List<ParsedTree> list = new ArrayList<ParsedTree>();
	ParsedTree current;
}
{
	(current = Object() { list.add(current); } (";" current = Object() { list.add(current); })* (";")?)?
	{
		return list;
	}
}


ParsedTree FunctionCallList() :
{
	ParsedTree current = null;
	List<ParsedTree> trees =  new ArrayList<ParsedTree>();
}
{
	(current = FunctionCall() {trees.add(current);})+ 
	{
		for (int i = trees.size()-2; i >= 0; i--)
		{
			trees.get(i+1).children.add(trees.get(i));	
		}	
		return current;
	}
}

ParsedTree FunctionCall() :
{
	ParsedTree tree;
	Token name, nameToken;
	List <String> params = new ArrayList<String>(); 
}
{
	name = <IDENTIFIER>(<LPAREN>(params = ParameterList())?<RPAREN>)? 
	{
		tree = ObjFactory.create(name.image);
		tree.name = name.image;
		tree.parameters =  params;
		return tree;
	} 
|

	(nameToken=<PLUS>|nameToken=<MINUS>|nameToken=<DIVIDE>)name=<IDENTIFIER> (<LPAREN>(params = ParameterList())?<RPAREN>)? 
	{
		String n = nameToken.image+name.image;
		tree = ObjFactory.create(n);
		tree.name = n;
		tree.parameters =  params;
		return tree;
	} 
		
}

List<String> ParameterList() :
{
	List<String> expressions = new ArrayList<String>();
	String current;
}
{
	current = Expression(){expressions.add(current);}(<COMMA>current=Expression(){expressions.add(current);})*
	{
		return expressions;
	}
}

void JEPFunctionCall() :
{
}
{
	<IDENTIFIER>(<LPAREN>(ParameterList())?<RPAREN>)?
}

/** Brace counting production. */
void UnaryExpression() :
{
}
{
	<REAL_LITERAL>	|  JEPFunctionCall()  | <LPAREN>Expression()<RPAREN> | <MINUS> UnaryExpression()
}

/** Brace counting production. */
String Expression() :
{
}
{
	UnaryExpression()((<PLUS>|<MINUS>|<DIVIDE>|<OTHERBINOP>)UnaryExpression())*
	{
		return dumpTokens(jjtThis);
	}
}
